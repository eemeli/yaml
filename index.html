
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>YAML</title>
    <link href="images/favicon.ico" rel="icon" type="image/ico" />

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-126084011-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-126084011-1');
    </script>
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo.png" class="logo" alt="Logo" />
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#yaml" class="toc-h1 toc-link" data-title="YAML">YAML</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#api-overview" class="toc-h2 toc-link" data-title="API Overview">API Overview</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#parse-amp-stringify" class="toc-h1 toc-link" data-title="Parse &amp; Stringify">Parse &amp; Stringify</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#yaml-parse" class="toc-h2 toc-link" data-title="YAML.parse">YAML.parse</a>
                  </li>
                  <li>
                    <a href="#yaml-stringify" class="toc-h2 toc-link" data-title="YAML.stringify">YAML.stringify</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#options" class="toc-h1 toc-link" data-title="Options">Options</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#data-schemas" class="toc-h2 toc-link" data-title="Data Schemas">Data Schemas</a>
                  </li>
                  <li>
                    <a href="#tag-stringifier-options" class="toc-h2 toc-link" data-title="Tag Stringifier Options">Tag Stringifier Options</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#documents" class="toc-h1 toc-link" data-title="Documents">Documents</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#parsing-documents" class="toc-h2 toc-link" data-title="Parsing Documents">Parsing Documents</a>
                  </li>
                  <li>
                    <a href="#creating-documents" class="toc-h2 toc-link" data-title="Creating Documents">Creating Documents</a>
                  </li>
                  <li>
                    <a href="#document-methods" class="toc-h2 toc-link" data-title="Document Methods">Document Methods</a>
                  </li>
                  <li>
                    <a href="#working-with-anchors" class="toc-h2 toc-link" data-title="Working with Anchors">Working with Anchors</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#content-nodes" class="toc-h1 toc-link" data-title="Content Nodes">Content Nodes</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#scalar-values" class="toc-h2 toc-link" data-title="Scalar Values">Scalar Values</a>
                  </li>
                  <li>
                    <a href="#collections" class="toc-h2 toc-link" data-title="Collections">Collections</a>
                  </li>
                  <li>
                    <a href="#alias-nodes" class="toc-h2 toc-link" data-title="Alias Nodes">Alias Nodes</a>
                  </li>
                  <li>
                    <a href="#creating-nodes" class="toc-h2 toc-link" data-title="Creating Nodes">Creating Nodes</a>
                  </li>
                  <li>
                    <a href="#comments" class="toc-h2 toc-link" data-title="Comments">Comments</a>
                  </li>
                  <li>
                    <a href="#blank-lines" class="toc-h2 toc-link" data-title="Blank Lines">Blank Lines</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#custom-data-types" class="toc-h1 toc-link" data-title="Custom Data Types">Custom Data Types</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#writing-custom-tags" class="toc-h2 toc-link" data-title="Writing Custom Tags">Writing Custom Tags</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#cst-parser" class="toc-h1 toc-link" data-title="CST Parser">CST Parser</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#parsecst" class="toc-h2 toc-link" data-title="parseCST">parseCST</a>
                  </li>
                  <li>
                    <a href="#cst-nodes" class="toc-h2 toc-link" data-title="CST Nodes">CST Nodes</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#errors" class="toc-h1 toc-link" data-title="Errors">Errors</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#yamlreferenceerror" class="toc-h2 toc-link" data-title="YAMLReferenceError">YAMLReferenceError</a>
                  </li>
                  <li>
                    <a href="#yamlsemanticerror" class="toc-h2 toc-link" data-title="YAMLSemanticError">YAMLSemanticError</a>
                  </li>
                  <li>
                    <a href="#yamlsyntaxerror" class="toc-h2 toc-link" data-title="YAMLSyntaxError">YAMLSyntaxError</a>
                  </li>
                  <li>
                    <a href="#yamlwarning" class="toc-h2 toc-link" data-title="YAMLWarning">YAMLWarning</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#yaml-syntax" class="toc-h1 toc-link" data-title="YAML Syntax">YAML Syntax</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#tags" class="toc-h2 toc-link" data-title="Tags">Tags</a>
                  </li>
                  <li>
                    <a href="#version-differences" class="toc-h2 toc-link" data-title="Version Differences">Version Differences</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://github.com/eemeli/yaml/releases'>Version <span id='version'>1.x.y</span> (changelog)</a></li>
            <li><a href='https://github.com/eemeli/yaml'>github.com/eemeli/yaml</a></li>
            <li><a href='https://www.npmjs.com/package/yaml'><code>npm install yaml</code></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='yaml'>YAML</h1>
<blockquote>
<p>To install:</p>
</blockquote>
<pre class="highlight sh tab-shell"><code>npm install yaml
<span class="c"># or</span>
yarn add yaml
</code></pre>
<p><code>yaml</code> is a new definitive library for <a href="http://yaml.org/">YAML</a>, a human friendly data serialization standard. This library:</p>

<ul>
<li>Supports all versions of the standard (1.0, 1.1, and 1.2),</li>
<li>Passes all of the <a href="https://github.com/yaml/yaml-test-suite">yaml-test-suite</a> tests,</li>
<li>Can accept any string as input without throwing, parsing as much YAML out of it as it can, and</li>
<li>Supports parsing, modifying, and writing YAML comments.</li>
</ul>

<p>The library is released under the ISC open source license, and the code is <a href="https://github.com/eemeli/yaml/">available on GitHub</a>. It runs on Node.js 6 and later with no external dependencies, and in browsers from IE 11 upwards (Note: <code>@babel/runtime</code> is used only by the <code>&quot;browser&quot;</code> entry point).</p>
<h2 id='api-overview'>API Overview</h2>
<p>The API provided by <code>yaml</code> has three layers, depending on how deep you need to go: <a href="#parse-amp-stringify">Parse &amp; Stringify</a>, <a href="#documents">Documents</a>, and the <a href="#cst-parser">CST Parser</a>. The first has the simplest API and &quot;just works&quot;, the second gets you all the bells and whistles supported by the library along with a decent <a href="#content-nodes">AST</a>, and the third is the closest to YAML source, making it fast, raw, and crude.</p>

<h3>Parse & Stringify</h3>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">YAML</span> <span class="nx">from</span> <span class="s1">'yaml'</span>
<span class="c1">// or</span>
<span class="kr">const</span> <span class="nx">YAML</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'yaml'</span><span class="p">)</span>
</code></pre>
<ul>
<li><a href="#yaml-parse"><code>YAML.parse(str, options): value</code></a></li>
<li><a href="#yaml-stringify"><code>YAML.stringify(value, options): string</code></a></li>
</ul>

<h3>Documents</h3>

<ul>
<li><a href="#creating-nodes"><code>YAML.createNode(value, wrapScalars, tag): Node</code></a></li>
<li><a href="#options"><code>YAML.defaultOptions</code></a></li>
<li><a href="#yaml-documents"><code>YAML.Document</code></a>

<ul>
<li><a href="#creating-documents"><code>constructor(options)</code></a></li>
<li><a href="#options"><code>defaults</code></a></li>
<li><a href="#working-with-anchors"><code>#anchors</code></a></li>
<li><a href="#content-nodes"><code>#contents</code></a></li>
<li><a href="#errors"><code>#errors</code></a></li>
</ul></li>
<li><a href="#parsing-documents"><code>YAML.parseAllDocuments(str, options): YAML.Document[]</code></a></li>
<li><a href="#parsing-documents"><code>YAML.parseDocument(str, options): YAML.Document</code></a></li>
</ul>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">Map</span> <span class="nx">from</span> <span class="s1">'yaml/map'</span>
<span class="kr">import</span> <span class="nx">Pair</span> <span class="nx">from</span> <span class="s1">'yaml/pair'</span>
<span class="kr">import</span> <span class="nx">Seq</span> <span class="nx">from</span> <span class="s1">'yaml/seq'</span>
</code></pre>
<ul>
<li><a href="#creating-nodes"><code>new Map()</code></a></li>
<li><a href="#creating-nodes"><code>new Pair(key, value)</code></a></li>
<li><a href="#creating-nodes"><code>new Seq()</code></a></li>
</ul>

<h3>CST Parser</h3>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">parseCST</span> <span class="nx">from</span> <span class="s1">'yaml/parse-cst'</span>
</code></pre>
<ul>
<li><a href="#parsecst"><code>parseCST(str): CSTDocument[]</code></a></li>
<li><a href="#parsecst"><code>YAML.parseCST(str): CSTDocument[]</code></a></li>
</ul>
<h1 id='parse-amp-stringify'>Parse &amp; Stringify</h1><pre class="highlight yaml tab-yaml"><code><span class="c1"># file.yml</span>
<span class="na">YAML</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">A human-readable data serialization language</span>
  <span class="pi">-</span> <span class="s">https://en.wikipedia.org/wiki/YAML</span>
<span class="na">yaml</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">A complete JavaScript implementation</span>
  <span class="pi">-</span> <span class="s">https://www.npmjs.com/package/yaml</span>
</code></pre>
<p>At its simplest, you can use <code>YAML.parse(str)</code> and <code>YAML.stringify(value)</code> just as you&#39;d use <code>JSON.parse(str)</code> and <code>JSON.stringify(value)</code>. If that&#39;s enough for you, everything else in these docs is really just implementation details.</p>
<h2 id='yaml-parse'>YAML.parse</h2><pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s1">'fs'</span>
<span class="kr">import</span> <span class="nx">YAML</span> <span class="nx">from</span> <span class="s1">'yaml'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'3.14159'</span><span class="p">)</span>
<span class="c1">// 3.14159</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'[ true, false, maybe, null ]\n'</span><span class="p">)</span>
<span class="c1">// [ true, false, 'maybe', null ]</span>

<span class="kr">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'./file.yml'</span><span class="p">,</span> <span class="s1">'utf8'</span><span class="p">)</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="c1">// { YAML:</span>
<span class="c1">//   [ 'A human-readable data serialization language',</span>
<span class="c1">//     'https://en.wikipedia.org/wiki/YAML' ],</span>
<span class="c1">//   yaml:</span>
<span class="c1">//   [ 'A complete JavaScript implementation',</span>
<span class="c1">//     'https://www.npmjs.com/package/yaml' ] }</span>
</code></pre><h4 id='yaml-parse-str-options-any'><code>YAML.parse(str, options = {}): any</code></h4>
<p><code>str</code> should be a string with YAML formatting. See <a href="#options">Options</a> for more information on the second parameter, an optional configuration object.</p>

<p>The returned value will match the type of the root value of the parsed YAML document, so Maps become objects, Sequences arrays, and scalars result in nulls, booleans, numbers and strings.</p>

<p><code>YAML.parse</code> may throw on error, and it may log warnings using <code>console.warn</code>. It only supports input consisting of a single YAML document; for multi-document support you should use <a href="#parsing-documents"><code>YAML.parseAllDocuments</code></a>.</p>
<h2 id='yaml-stringify'>YAML.stringify</h2><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span>
<span class="c1">// '3.14159\n'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s1">'maybe'</span><span class="p">,</span> <span class="kc">null</span><span class="p">])</span>
<span class="c1">// `- true</span>
<span class="c1">// - false</span>
<span class="c1">// - maybe</span>
<span class="c1">// - null</span>
<span class="c1">// `</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">number</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">plain</span><span class="p">:</span> <span class="s1">'string'</span><span class="p">,</span> <span class="na">block</span><span class="p">:</span> <span class="s1">'two\nlines\n'</span> <span class="p">})</span>
<span class="c1">// `number: 3</span>
<span class="c1">// plain: string</span>
<span class="c1">// block: &gt;</span>
<span class="c1">//   two</span>
<span class="c1">//</span>
<span class="c1">//   lines</span>
<span class="c1">// `</span>
</code></pre><h4 id='yaml-stringify-value-options-string'><code>YAML.stringify(value, options = {}): string</code></h4>
<p><code>value</code> can be of any type. The returned string will always include <code>\n</code> as the last character, as is expected of YAML documents. See <a href="#options">Options</a> for more information on the second parameter, an optional configuration object.</p>

<p>As strings in particular may be represented in a number of different styles, the simplest option for the value in question will always be chosen, depending mostly on the presence of escaped or control characters and leading &amp; trailing whitespace.</p>

<p>To create a stream of documents, you may call <code>YAML.stringify</code> separately for each document&#39;s <code>value</code>, and concatenate the documents with the string <code>...\n</code> as a separator.</p>
<h1 id='options'>Options</h1><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span>
<span class="c1">// { keepBlobsInJSON: true,</span>
<span class="c1">//   keepNodeTypes: true,</span>
<span class="c1">//   version: '1.2' }</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">.</span><span class="nx">defaults</span>
<span class="c1">// { '1.0': { merge: true, schema: 'yaml-1.1' },</span>
<span class="c1">//   '1.1': { merge: true, schema: 'yaml-1.1' },</span>
<span class="c1">//   '1.2': { merge: false, schema: 'core' } }</span>
</code></pre><h4 id='yaml-defaultoptions'><code>YAML.defaultOptions</code></h4><h4 id='yaml-document-defaults'><code>YAML.Document.defaults</code></h4>
<p><code>yaml</code> defines options in three places: as an argument of parse, create and stringify calls, in the values of <code>YAML.defaultOptions</code>, and in the version-dependent <code>YAML.Document.defaults</code> object. Values set in <code>YAML.defaultOptions</code> override version-dependent defaults, and argument options override both.</p>

<p>The <code>version</code> option value (<code>&#39;1.2&#39;</code> by default) may be overridden by any document-specific <code>%YAML</code> directive.</p>

<table><thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>anchorPrefix</td>
<td><code>string</code></td>
<td>Default prefix for anchors. By default <code>&#39;a&#39;</code>, resulting in anchors <code>a1</code>, <code>a2</code>, etc.</td>
</tr>
<tr>
<td>keepBlobsInJSON</td>
<td><code>boolean</code></td>
<td>Allow non-JSON JavaScript objects to remain in the <code>toJSON</code> output. Relevant with the YAML 1.1 <code>!!timestamp</code> and <code>!!binary</code> tags. By default <code>true</code>.</td>
</tr>
<tr>
<td>keepCstNodes</td>
<td><code>boolean</code></td>
<td>Include references in the AST to each node&#39;s corresponding CST node. By default <code>false</code>.</td>
</tr>
<tr>
<td>keepNodeTypes</td>
<td><code>boolean</code></td>
<td>Store the original node type when parsing documents. By default <code>true</code>.</td>
</tr>
<tr>
<td>mapAsMap</td>
<td><code>boolean</code></td>
<td>When outputting JS, use Map rather than Object to represent mappings. By default <code>false</code>.</td>
</tr>
<tr>
<td>merge</td>
<td><code>boolean</code></td>
<td>Enable support for <code>&lt;&lt;</code> merge keys.</td>
</tr>
<tr>
<td>schema</td>
<td><code>&#39;core&#39;</code> &vert; <code>&#39;failsafe&#39;</code> &vert; <code>&#39;json&#39;</code> &vert; <code>&#39;yaml-1.1&#39;</code></td>
<td>The base schema to use. By default <code>&#39;core&#39;</code> for YAML 1.2 and <code>&#39;yaml-1.1&#39;</code> for earlier versions.</td>
</tr>
<tr>
<td>tags</td>
<td><a href="#tag"><code>Tag[]</code></a> &vert; <code>function</code></td>
<td>Array of additional (custom) tags to include in the schema</td>
</tr>
<tr>
<td>version</td>
<td><code>string</code></td>
<td>The YAML version used by documents without a <code>%YAML</code> directive. By default <code>&#39;1.2&#39;</code>.</td>
</tr>
</tbody></table>
<h2 id='data-schemas'>Data Schemas</h2><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'3'</span><span class="p">)</span> <span class="c1">// 3</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'3'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="s1">'failsafe'</span> <span class="p">})</span> <span class="c1">// '3'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'No'</span><span class="p">)</span> <span class="c1">// 'No'</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'No'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="s1">'json'</span> <span class="p">})</span> <span class="c1">// SyntaxError: Unresolved plain scalar "No"</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'No'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="s1">'yaml-1.1'</span> <span class="p">})</span> <span class="c1">// false</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'No'</span><span class="p">,</span> <span class="p">{</span> <span class="na">version</span><span class="p">:</span> <span class="s1">'1.1'</span> <span class="p">})</span> <span class="c1">// false</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'{[1, 2]: many}'</span><span class="p">)</span> <span class="c1">// { '[1,2]': 'many' }</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'{[1, 2]: many}'</span><span class="p">,</span> <span class="p">{</span> <span class="na">mapAsMap</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="c1">// Map { [ 1, 2 ] =&gt; 'many' }</span>
</code></pre>
<p>Aside from defining the language structure, the YAML 1.2 spec defines a number of different <em>schemas</em> that may be used. The default is the <a href="http://yaml.org/spec/1.2/spec.html#id2804923"><code>core</code></a> schema, which is the most common one. The <a href="http://yaml.org/spec/1.2/spec.html#id2803231"><code>json</code></a> schema is effectively the minimum schema required to parse JSON; both it and the core schema are supersets of the minimal <a href="http://yaml.org/spec/1.2/spec.html#id2802346"><code>failsafe</code></a> schema.</p>

<p>The <code>yaml-1.1</code> schema matches the more liberal <a href="http://yaml.org/type/">YAML 1.1 types</a> (also used by YAML 1.0), including binary data and timestamps as distinct tags as well as accepting greater variance in scalar values (with e.g. <code>&#39;No&#39;</code> being parsed as <code>false</code> rather than a string value). The <code>!!value</code> and <code>!!yaml</code> types are not supported.</p>
<pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kc">true</span>

<span class="kr">const</span> <span class="nx">mergeResult</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">`
source: &amp;base { a: 1, b: 2 }
target:
  &lt;&lt;: *base
  b: base
`</span><span class="p">)</span>

<span class="nx">mergeResult</span><span class="p">.</span><span class="nx">target</span>
<span class="c1">// { a: 1, b: 'base' }</span>
</code></pre>
<p><strong>Merge</strong> keys are a <a href="http://yaml.org/type/merge.html">YAML 1.1 feature</a> that is not a part of the 1.2 spec. To use a merge key, assign an alias node or an array of alias nodes as the value of a <code>&lt;&lt;</code> key in a mapping.</p>
<h2 id='tag-stringifier-options'>Tag Stringifier Options</h2><pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">nullOptions</span><span class="p">,</span> <span class="nx">strOptions</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'yaml/schema'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="s1">'this is'</span><span class="p">:</span> <span class="kc">null</span> <span class="p">})</span>
<span class="c1">// this is: null</span>

<span class="nx">nullOptions</span>
<span class="c1">// { nullStr: 'null' }</span>
<span class="nx">nullOptions</span><span class="p">.</span><span class="nx">nullStr</span> <span class="o">=</span> <span class="s1">'~'</span>

<span class="nx">strOptions</span>
<span class="c1">// { defaultType: 'PLAIN',</span>
<span class="c1">//   doubleQuoted: { jsonEncoding: false, minMultiLineLength: 40 },</span>
<span class="c1">//   fold: { lineWidth: 80, minContentWidth: 20 } }</span>
<span class="nx">strOptions</span><span class="p">.</span><span class="nx">defaultType</span> <span class="o">=</span> <span class="s1">'QUOTE_SINGLE'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="s1">'this is'</span><span class="p">:</span> <span class="kc">null</span> <span class="p">})</span>
<span class="c1">// 'this is': ~</span>
</code></pre>
<p>To customise the YAML stringification, the <code>nullOptions</code> and <code>strOptions</code> objects are exported from <code>&#39;yaml/schema&#39;</code>. Note that these values are used by all documents. For example, to disable the automatic line wrapping, set <code>strOptions.fold.lineWidth</code> to <code>0</code>.</p>

<p>The optional <code>!!binary</code> type (available at <code>&#39;yaml/types/binary&#39;</code>) also provides for some configuration via its <code>options</code> object.</p>
<h1 id='documents'>Documents</h1>
<p>In order to work with YAML features not directly supported by native JavaScript data types, such as comments and non-string keys, <code>yaml</code> provides the <code>YAML.Document</code> API.</p>
<h2 id='parsing-documents'>Parsing Documents</h2><pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">fs</span> <span class="nx">from</span> <span class="s1">'fs'</span>
<span class="kr">import</span> <span class="nx">YAML</span> <span class="nx">from</span> <span class="s1">'yaml'</span>

<span class="kr">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="s1">'./file.yml'</span><span class="p">,</span> <span class="s1">'utf8'</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span>
<span class="c1">// YAMLMap {</span>
<span class="c1">//   items:</span>
<span class="c1">//    [ Pair {</span>
<span class="c1">//        key: Scalar { value: 'YAML', range: [ 0, 4 ] },</span>
<span class="c1">//        value:</span>
<span class="c1">//         YAMLSeq {</span>
<span class="c1">//           items:</span>
<span class="c1">//            [ Scalar {</span>
<span class="c1">//                value: 'A human-readable data serialization language',</span>
<span class="c1">//                range: [ 10, 55 ] },</span>
<span class="c1">//              Scalar {</span>
<span class="c1">//                value: 'https://en.wikipedia.org/wiki/YAML',</span>
<span class="c1">//                range: [ 59, 94 ] } ],</span>
<span class="c1">//           tag: 'tag:yaml.org,2002:seq',</span>
<span class="c1">//           range: [ 8, 94 ] } },</span>
<span class="c1">//      Pair {</span>
<span class="c1">//        key: Scalar { value: 'yaml', range: [ 94, 98 ] },</span>
<span class="c1">//        value:</span>
<span class="c1">//         YAMLSeq {</span>
<span class="c1">//           items:</span>
<span class="c1">//            [ Scalar {</span>
<span class="c1">//                value: 'A complete JavaScript implementation',</span>
<span class="c1">//                range: [ 104, 141 ] },</span>
<span class="c1">//              Scalar {</span>
<span class="c1">//                value: 'https://www.npmjs.com/package/yaml',</span>
<span class="c1">//                range: [ 145, 180 ] } ],</span>
<span class="c1">//           tag: 'tag:yaml.org,2002:seq',</span>
<span class="c1">//           range: [ 102, 180 ] } } ],</span>
<span class="c1">//   tag: 'tag:yaml.org,2002:map',</span>
<span class="c1">//   range: [ 0, 180 ] }</span>
</code></pre><h4 id='yaml-parsedocument-str-options-yaml-document'><code>YAML.parseDocument(str, options = {}): YAML.Document</code></h4>
<p>Parses a single <code>YAML.Document</code> from the input <code>str</code>; used internally by <code>YAML.parse</code>. Will include an error if <code>str</code> contains more than one document. See <a href="#options">Options</a> for more information on the second parameter.</p>

<p><br/></p>
<h4 id='yaml-parsealldocuments-str-options-yaml-document'><code>YAML.parseAllDocuments(str, options = {}): YAML.Document[]</code></h4>
<p>When parsing YAML, the input string <code>str</code> may consist of a stream of documents separated from each other by <code>...</code> document end marker lines. <code>YAML.parseAllDocuments</code> will return an array of <code>Document</code> objects that allow these documents to be parsed and manipulated with more control. See <a href="#options">Options</a> for more information on the second parameter.</p>

<p><br/></p>

<p>These functions should never throw; errors and warnings are included in the documents&#39; <code>errors</code> and <code>warnings</code> arrays. In particular, if <code>errors</code> is not empty it&#39;s likely that the document&#39;s parsed <code>contents</code> are not entirely correct.</p>

<p>The <code>contents</code> of a parsed document will always consist of <code>Scalar</code>, <code>Map</code>, <code>Seq</code> or <code>null</code> values.</p>
<h2 id='creating-documents'>Creating Documents</h2><h4 id='new-yaml-document-options'><code>new YAML.Document(options = {})</code></h4>
<table><thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>anchors</td>
<td><a href="#anchors"><code>Anchors</code></a></td>
<td>Anchors associated with the document&#39;s nodes; also provides alias &amp; merge node creators.</td>
</tr>
<tr>
<td>commentBefore</td>
<td><code>string?</code></td>
<td>A comment at the very beginning of the document. If not empty, separated from the rest of the document by a blank line when stringified.</td>
</tr>
<tr>
<td>comment</td>
<td><code>string?</code></td>
<td>A comment at the end of the document. If not empty, separated from the rest of the document by a blank line when stringified.</td>
</tr>
<tr>
<td>contents</td>
<td><a href="#content-nodes"><code>Node</code></a>&vert;<code>any</code></td>
<td>The document contents.</td>
</tr>
<tr>
<td>errors</td>
<td><code>Error[]</code></td>
<td>Errors encountered during parsing.</td>
</tr>
<tr>
<td>schema</td>
<td><code>Schema</code></td>
<td>The schema used with the document.</td>
</tr>
<tr>
<td>tagPrefixes</td>
<td><code>Prefix[]</code></td>
<td>Array of prefixes; each will have a string <code>handle</code> that starts and ends with <code>!</code> and a string <code>prefix</code> that the handle will be replaced by.</td>
</tr>
<tr>
<td>version</td>
<td><code>string?</code></td>
<td>The parsed version of the source document; if true-ish, stringified output will include a <code>%YAML</code> directive.</td>
</tr>
<tr>
<td>warnings</td>
<td><code>Error[]</code></td>
<td>Warnings encountered during parsing.</td>
</tr>
</tbody></table>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">version</span> <span class="o">=</span> <span class="kc">true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">commentBefore</span> <span class="o">=</span> <span class="s1">' A commented document'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'some'</span><span class="p">,</span> <span class="s1">'values'</span><span class="p">,</span> <span class="p">{</span> <span class="na">balloons</span><span class="p">:</span> <span class="mi">99</span> <span class="p">}]</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// # A commented document</span>
<span class="c1">// %YAML 1.2</span>
<span class="c1">// ---</span>
<span class="c1">// - some</span>
<span class="c1">// - values</span>
<span class="c1">// - balloons: 99</span>
</code></pre>
<p>The Document members are all modifiable, though it&#39;s unlikely that you&#39;ll have reason to change <code>errors</code>, <code>schema</code> or <code>warnings</code>. In particular you may be interested in both reading and writing <strong><code>contents</code></strong>. Although <code>YAML.parseDocument()</code> and <code>YAML.parseAllDocuments()</code> will leave it with <code>Map</code>, <code>Seq</code>, <code>Scalar</code> or <code>null</code> contents, it can be set to anything.</p>

<p>During stringification, a document with a true-ish <code>version</code> value will include a <code>%YAML</code> directive; the version number will be set to <code>1.2</code> unless the <code>yaml-1.1</code> schema is in use.</p>
<h2 id='document-methods'>Document Methods</h2>
<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>listNonDefaultTags()</td>
<td><code>string[]</code></td>
<td>List the tags used in the document that are not in the default <code>tag:yaml.org,2002:</code> namespace.</td>
</tr>
<tr>
<td>parse(cst)</td>
<td><code>Document</code></td>
<td>Parse a CST into this document. Mostly an internal method, modifying the document according to the contents of the parsed <code>cst</code>. Calling this multiple times on a Document is not recommended.</td>
</tr>
<tr>
<td>setSchema()</td>
<td><code>void</code></td>
<td>When a document is created with <code>new YAML.Document()</code>, the schema object is not set as it may be influenced by parsed directives; call this to set it manually.</td>
</tr>
<tr>
<td>setTagPrefix(handle, prefix)</td>
<td><code>void</code></td>
<td>Set <code>handle</code> as a shorthand string for the <code>prefix</code> tag namespace.</td>
</tr>
<tr>
<td>toJSON()</td>
<td><code>any</code></td>
<td>A plain JavaScript representation of the document <code>contents</code>.</td>
</tr>
<tr>
<td>toString()</td>
<td><code>string</code></td>
<td>A YAML representation of the document.</td>
</tr>
</tbody></table>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s1">'a: 1\nb: [2, 3]\n'</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([])</span> <span class="c1">// YAMLMap { items: [Pair, Pair], ... }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">hasIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// -&gt; doc.get('b').items.length === 3</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">deleteIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 4</span>
</code></pre>
<p>In addition to the above, the document object also provides the same <strong>accessor methods</strong> as <a href="#collections">collections</a>, based on the top-level collection: <code>add</code>, <code>delete</code>, <code>get</code>, <code>has</code>, and <code>set</code>, along with their deeper variants <code>addIn</code>, <code>deleteIn</code>, <code>getIn</code>, <code>hasIn</code>, and <code>setIn</code>. For the <code>*In</code> methods using an empty <code>path</code> value (i.e. <code>null</code>, <code>undefined</code>, or <code>[]</code>) will refer to the document&#39;s top-level <code>contents</code>.</p>

<p>To define a tag prefix to use when stringifying, use <strong><code>setTagPrefix(handle, prefix)</code></strong> rather than setting a value directly in <code>tagPrefixes</code>. This will guarantee that the <code>handle</code> is valid (by throwing an error), and will overwrite any previous definition for the <code>handle</code>. Use an empty <code>prefix</code> value to remove a prefix.</p>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">timestamp</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'yaml/types/timestamp'</span>

<span class="kr">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="s1">'1969-07-21T02:56:15Z'</span>
<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="p">{</span> <span class="na">tags</span><span class="p">:</span> <span class="p">[</span><span class="nx">timestamp</span><span class="p">]</span> <span class="p">})</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// Date { 1969-07-21T02:56:15.000Z }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">options</span><span class="p">.</span><span class="nx">keepBlobsInJSON</span> <span class="o">=</span> <span class="kc">false</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// '1969-07-21T02:56:15.000Z'</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// '1969-07-21T02:56:15\n'</span>
</code></pre>
<p>For a plain JavaScript representation of the document, <strong><code>toJSON()</code></strong> is your friend. By default the values wrapped in scalar nodes will not be forced to JSON, so e.g. a <code>!!timestamp</code> will remain a <code>Date</code> in the output. To change this behaviour and enforce JSON values only, set the <a href="#options"><code>keepBlobsInJSON</code> option</a> to <code>false</code>.</p>

<p>Conversely, to stringify a document as YAML, use <strong><code>toString()</code></strong>. This will also be called by <code>String(doc)</code>. This method will throw if the <code>errors</code> array is not empty.</p>
<h2 id='working-with-anchors'>Working with Anchors</h2>
<p>A description of <a href="#alias-nodes">alias and merge nodes</a> is included in the next section.</p>

<p><br/></p>
<h4 id='yaml-document-anchors'><code>YAML.Document#anchors</code></h4>
<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>createAlias(node: Node, name?: string)</td>
<td><code>Alias</code></td>
<td>Create a new <code>Alias</code> node, adding the required anchor for <code>node</code>. If <code>name</code> is empty, a new anchor name will be generated.</td>
</tr>
<tr>
<td>createMergePair(...Node)</td>
<td><code>Merge</code></td>
<td>Create a new <code>Merge</code> node with the given source nodes. Non-<code>Alias</code> sources will be automatically wrapped.</td>
</tr>
<tr>
<td>getName(node: Node)</td>
<td><code>string?</code></td>
<td>The anchor name associated with <code>node</code>, if set.</td>
</tr>
<tr>
<td>getNode(name: string)</td>
<td><code>Node?</code></td>
<td>The node associated with the anchor <code>name</code>, if set.</td>
</tr>
<tr>
<td>newName(prefix: string)</td>
<td><code>string</code></td>
<td>Find an available anchor name with the given <code>prefix</code> and a numerical suffix.</td>
</tr>
<tr>
<td>setAnchor(node: Node, name?: string)</td>
<td><code>string?</code></td>
<td>Associate an anchor with <code>node</code>. If <code>name</code> is empty, a new name will be generated.</td>
</tr>
</tbody></table>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="s1">'[{ a: A }, { b: B }]'</span>
<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">anchors</span><span class="p">,</span> <span class="nx">contents</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">doc</span>
<span class="kr">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">contents</span><span class="p">.</span><span class="nx">items</span>
<span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 'a1'</span>
<span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 'a2'</span>
<span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="s1">'a1'</span><span class="p">)</span> <span class="c1">// 'a1'</span>
<span class="nx">anchors</span><span class="p">.</span><span class="nx">getName</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// undefined</span>
<span class="nx">anchors</span><span class="p">.</span><span class="nx">getNode</span><span class="p">(</span><span class="s1">'a2'</span><span class="p">)</span>
<span class="c1">// { value: 'B', range: [ 16, 18 ], type: 'PLAIN' }</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ { a: A }, { b: &amp;a2 B } ]</span>

<span class="kr">const</span> <span class="nx">alias</span> <span class="o">=</span> <span class="nx">anchors</span><span class="p">.</span><span class="nx">createAlias</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="s1">'AA'</span><span class="p">)</span>
<span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// [ { a: 'A' }, { b: 'B' }, { a: 'A' } ]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ &amp;AA { a: A }, { b: &amp;a2 B }, *AA ]</span>

<span class="kr">const</span> <span class="nx">merge</span> <span class="o">=</span> <span class="nx">anchors</span><span class="p">.</span><span class="nx">createMergePair</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
<span class="nx">b</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">merge</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// [ { a: 'A' }, { b: 'B', a: 'A' }, { a: 'A' } ]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ &amp;AA { a: A }, { b: &amp;a2 B, &lt;&lt;: *AA }, *AA ]</span>

<span class="c1">// This creates a circular reference</span>
<span class="nx">merge</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">createAlias</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span> <span class="c1">// [RangeError: Maximum call stack size exceeded]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [</span>
<span class="c1">//   &amp;AA { a: A },</span>
<span class="c1">//   &amp;a3 {</span>
<span class="c1">//       b: &amp;a2 B,</span>
<span class="c1">//       &lt;&lt;:</span>
<span class="c1">//         [ *AA, *a3 ]</span>
<span class="c1">//     },</span>
<span class="c1">//   *AA</span>
<span class="c1">// ]</span>
</code></pre>
<p>The constructors for <code>Alias</code> and <code>Merge</code> are not directly exported by the library, as they depend on the document&#39;s anchors; instead you&#39;ll need to use <strong><code>createAlias(node, name)</code></strong> and <strong><code>createMergePair(...sources)</code></strong>. You should make sure to only add alias and merge nodes to the document after the nodes to which they refer, or the document&#39;s YAML stringification will fail.</p>

<p>It is valid to have an anchor associated with a node even if it has no aliases. <code>yaml</code> will not allow you to associate the same name with more than one node, even though this is allowed by the YAML spec (all but the last instance will have numerical suffixes added). To add or reassign an anchor, use <strong><code>setAnchor(node, name)</code></strong>. The second parameter is optional, and if left out either the pre-existing anchor name of the node will be used, or a new one generated. To remove an anchor, use <code>setAnchor(null, name)</code>. The function will return the new anchor&#39;s name, or <code>null</code> if both of its arguments are <code>null</code>.</p>

<p>While the <code>merge</code> option needs to be true to parse <code>Merge</code> nodes as such, this is not required during stringification.</p>
<h1 id='content-nodes'>Content Nodes</h1>
<p>After parsing, the <code>contents</code> value of each <code>YAML.Document</code> is the root of an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> of nodes representing the document (or <code>null</code> for an empty document).</p>
<h2 id='scalar-values'>Scalar Values</h2><pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">comment</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>   <span class="c1">// a comment on or immediately after this</span>
  <span class="nx">commentBefore</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span> <span class="c1">// a comment before this</span>
  <span class="nx">range</span><span class="p">:</span> <span class="p">?[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="p">],</span>
      <span class="c1">// the [start, end] range of characters of the source parsed</span>
      <span class="c1">// into this node (undefined for pairs or if not parsed)</span>
  <span class="nx">spaceBefore</span><span class="p">:</span> <span class="p">?</span><span class="kr">boolean</span><span class="p">,</span>
      <span class="c1">// a blank line before this node and its commentBefore</span>
  <span class="nx">tag</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>       <span class="c1">// a fully qualified tag, if required</span>
  <span class="nx">toJSON</span><span class="p">():</span> <span class="nx">any</span>       <span class="c1">// a plain JS representation of this node</span>
<span class="p">}</span>
</code></pre>
<p>For scalar values, the <code>tag</code> will not be set unless it was explicitly defined in the source document; this also applies for unsupported tags that have been resolved using a fallback tag (string, <code>Map</code>, or <code>Seq</code>).</p>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Scalar</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">format</span><span class="p">:</span> <span class="s1">'BIN'</span> <span class="o">|</span> <span class="s1">'HEX'</span> <span class="o">|</span> <span class="s1">'OCT'</span> <span class="o">|</span> <span class="s1">'TIME'</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
      <span class="c1">// By default (undefined), numbers use decimal notation.</span>
      <span class="c1">// The YAML 1.2 core schema only supports 'HEX' and 'OCT'.</span>
  <span class="nx">type</span><span class="p">:</span>
    <span class="s1">'BLOCK_FOLDED'</span> <span class="o">|</span> <span class="s1">'BLOCK_LITERAL'</span> <span class="o">|</span> <span class="s1">'PLAIN'</span> <span class="o">|</span>
    <span class="s1">'QUOTE_DOUBLE'</span> <span class="o">|</span> <span class="s1">'QUOTE_SINGLE'</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">any</span>
<span class="p">}</span>
</code></pre>
<p>A parsed document&#39;s contents will have all of its non-object values wrapped in <code>Scalar</code> objects, which themselves may be in some hierarchy of <code>Map</code> and <code>Seq</code> collections. However, this is not a requirement for the document&#39;s stringification, which is rather tolerant regarding its input values, and will use <a href="#yaml-createnode"><code>YAML.createNode</code></a> when encountering an unwrapped value.</p>

<p>When stringifying, the node <code>type</code> will be taken into account by <code>!!str</code> and <code>!!binary</code> values, and ignored by other scalars. On the other hand, <code>!!int</code> and <code>!!float</code> stringifiers will take <code>format</code> into account.</p>
<h2 id='collections'>Collections</h2><pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Pair</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">key</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="p">,</span>    <span class="c1">// key and value are always Node or null</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="p">,</span>  <span class="c1">// when parsed, but can be set to anything</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'PAIR'</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Map</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Pair</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'FLOW_MAP'</span> <span class="o">|</span> <span class="s1">'MAP'</span> <span class="o">|</span> <span class="kc">undefined</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Seq</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'FLOW_SEQ'</span> <span class="o">|</span> <span class="s1">'SEQ'</span> <span class="o">|</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre>
<p>Within all YAML documents, two forms of collections are supported: sequential <code>Seq</code> collections and key-value <code>Map</code> collections. The JavaScript representations of these collections both have an <code>items</code> array, which may (<code>Seq</code>) or must (<code>Map</code>) consist of <code>Pair</code> objects that contain a <code>key</code> and a <code>value</code> of any type, including <code>null</code>. The <code>items</code> array of a <code>Seq</code> object may contain values of any type.</p>

<p>When stringifying collections, by default block notation will be used. Flow notation will be selected if <code>type</code> is <code>FLOW_MAP</code> or <code>FLOW_SEQ</code>, the collection is within a surrounding flow collection, or if the collection is in an implicit key.</p>

<p>The <code>yaml-1.1</code> schema includes <a href="https://yaml.org/type/index.html">additional collections</a> that are based on <code>Map</code> and <code>Seq</code>: <code>OMap</code> and <code>Pairs</code> are sequences of <code>Pair</code> objects (<code>OMap</code> requires unique keys &amp; corresponds to the JS Map object), and <code>Set</code> is a map of keys with null values that corresponds to the JS Set object.</p>

<p>All of the collections provide the following accessor methods:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>add(value)</td>
<td><code>void</code></td>
<td>Adds a value to the collection. For <code>!!map</code> and <code>!!omap</code> the value must be a Pair instance or a <code>{ key, value }</code> object, which may not have a key that already exists in the map.</td>
</tr>
<tr>
<td>delete(key)</td>
<td><code>boolean</code></td>
<td>Removes a value from the collection. Returns <code>true</code> if the item was found and removed.</td>
</tr>
<tr>
<td>get(key,&nbsp;[keepScalar])</td>
<td><code>any</code></td>
<td>Returns item at <code>key</code>, or <code>undefined</code> if not found. By default unwraps scalar values from their surrounding node; to disable set <code>keepScalar</code> to <code>true</code> (collections are always returned intact).</td>
</tr>
<tr>
<td>has(key)</td>
<td><code>boolean</code></td>
<td>Checks if the collection includes a value with the key <code>key</code>.</td>
</tr>
<tr>
<td>set(key, value)</td>
<td><code>any</code></td>
<td>Sets a value in this collection. For <code>!!set</code>, <code>value</code> needs to be a boolean to add/remove the item from the set.</td>
</tr>
</tbody></table>
<pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">createNode</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">})</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span> <span class="na">key</span><span class="p">:</span> <span class="s1">'c'</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="mi">4</span> <span class="p">})</span>
  <span class="c1">// =&gt; map.get('c') === 4 &amp;&amp; map.has('c') === true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// -&gt; map.getIn(['b', 2]) === 5</span>
<span class="nx">map</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)</span> <span class="c1">// true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">deleteIn</span><span class="p">([</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'f'</span><span class="p">])</span> <span class="c1">// false</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="nx">YAML</span><span class="p">.</span><span class="nx">createNode</span><span class="p">(</span><span class="s1">'a'</span><span class="p">),</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Scalar { value: 1 }</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 3</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="s1">'c'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">hasIn</span><span class="p">([</span><span class="s1">'b'</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">])</span> <span class="c1">// true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span><span class="s1">'c'</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
  <span class="c1">// =&gt; map.get('c') === null &amp;&amp; map.has('c') === true</span>
<span class="nx">map</span><span class="p">.</span><span class="nx">setIn</span><span class="p">([</span><span class="s1">'c'</span><span class="p">,</span> <span class="s1">'x'</span><span class="p">])</span>
  <span class="c1">// throws Error:</span>
  <span class="c1">// Expected YAML collection at c. Remaining path: x</span>
</code></pre>
<p>For all of these methods, the keys may be nodes or their wrapped scalar values (i.e. <code>42</code> will match <code>Scalar { value: 42 }</code>) . Keys for <code>!!seq</code> should be positive integers, or their string representations. <code>add()</code> and <code>set()</code> do not automatically call <code>createNode()</code> to wrap the value.</p>

<p>Each of the methods also has a variant that requires an iterable as the first parameter, and allows fetching or modifying deeper collections: <code>addIn(path, value)</code>, <code>deleteIn(path)</code>, <code>getIn(path, keepScalar)</code>, <code>hasIn(path)</code>, <code>setIn(path, value)</code>. <code>getIn</code> and <code>hasIn</code> will return <code>undefined</code> or <code>false</code> (respectively) if any of the intermediate collections is not found or if the key path attempts to extend within a scalar value, but the others will throw an error in such cases. Note that for <code>addIn</code> the path argument points to the collection rather than the item.</p>
<h2 id='alias-nodes'>Alias Nodes</h2><pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Alias</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">source</span><span class="p">:</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">Map</span> <span class="o">|</span> <span class="nx">Seq</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'ALIAS'</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'[ &amp;x { X: 42 }, Y, *x ]'</span><span class="p">)</span>
  <span class="c1">// =&gt; [ { X: 42 }, 'Y', { X: 42 } ]</span>
<span class="nx">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">Z</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="c1">// =&gt; [ { X: 42, Z: 13 }, 'Y', { X: 42, Z: 13 } ]</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
  <span class="c1">// - &amp;a1</span>
  <span class="c1">//   X: 42</span>
  <span class="c1">//   Z: 13</span>
  <span class="c1">// - Y</span>
  <span class="c1">// - *a1</span>
</code></pre>
<p><code>Alias</code> nodes provide a way to include a single node in multiple places in a document; the <code>source</code> of an alias node must be a preceding node in the document. Circular references are fully supported, and where possible the JS representation of alias nodes will be the actual source object.</p>

<p>When directly stringifying JS structures with <code>YAML.stringify()</code>, multiple references to the same object will result in including an autogenerated anchor at its first instance, and alias nodes to that anchor at later references. Directly calling <code>YAML.createNode()</code> will not create anchors or alias nodes, allowing for greater manual control.</p>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Merge</span> <span class="kr">extends</span> <span class="nx">Pair</span> <span class="p">{</span>
  <span class="nl">key</span><span class="p">:</span> <span class="nx">Scalar</span><span class="p">(</span><span class="s1">'&lt;&lt;'</span><span class="p">),</span>      <span class="c1">// defined by the type specification</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">Seq</span><span class="o">&lt;</span><span class="nx">Alias</span><span class="p">(</span><span class="nx">Map</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// stringified as *A if length = 1</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'MERGE_PAIR'</span>
<span class="p">}</span>
</code></pre>
<p><code>Merge</code> nodes are not a core YAML 1.2 feature, but are defined as a <a href="http://yaml.org/type/merge.html">YAML 1.1 type</a>. They are only valid directly within a <code>Map#items</code> array and must contain one or more <code>Alias</code> nodes that themselves refer to <code>Map</code> nodes. When the surrounding map is resolved as a plain JS object, the key-value pairs of the aliased maps will be included in the object. Earlier <code>Alias</code> nodes override later ones, as do values set in the object directly.</p>

<p>To create and work with alias and merge nodes, you should use the <a href="#working-with-anchors"><code>YAML.Document#anchors</code></a> object.</p>
<h2 id='creating-nodes'>Creating Nodes</h2><pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">createNode</span><span class="p">([</span><span class="s1">'some'</span><span class="p">,</span> <span class="s1">'values'</span><span class="p">,</span> <span class="p">{</span> <span class="na">balloons</span><span class="p">:</span> <span class="mi">99</span> <span class="p">}])</span>
<span class="c1">// YAMLSeq {</span>
<span class="c1">//   items:</span>
<span class="c1">//    [ Scalar { value: 'some' },</span>
<span class="c1">//      Scalar { value: 'values' },</span>
<span class="c1">//      YAMLMap {</span>
<span class="c1">//        items:</span>
<span class="c1">//         [ Pair {</span>
<span class="c1">//             key: Scalar { value: 'balloons' },</span>
<span class="c1">//             value: Scalar { value: 99 } } ] } ] }</span>

<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span> <span class="o">=</span> <span class="nx">seq</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="s1">' A commented item'</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// - some # A commented item</span>
<span class="c1">// - values</span>
<span class="c1">// - balloons: 99</span>
</code></pre><h4 id='yaml-createnode-value-wrapscalars-tag-node'><code>YAML.createNode(value, wrapScalars?, tag?): Node</code></h4>
<p><code>YAML.createNode</code> recursively turns objects into <a href="#collections">collections</a>. Generic objects as well as <code>Map</code> and its descendants become mappings, while arrays and other iterable objects result in sequences. If <code>wrapScalars</code> is undefined or <code>true</code>, it also wraps plain values in <code>Scalar</code> objects; if it is false and <code>value</code> is not an object, it will be returned directly.</p>

<p>To specify the collection type, set <code>tag</code> to its identifying string, e.g. <code>&quot;!!omap&quot;</code>. Note that this requires the corresponding tag to be available based on the default options. To use a specific document&#39;s schema, use the wrapped method <code>doc.schema.createNode(value, wrapScalars, tag)</code>.</p>

<p>The primary purpose of this function is to enable attaching comments or other metadata to a value, or to otherwise exert more fine-grained control over the stringified output. To that end, you&#39;ll need to assign its return value to the <code>contents</code> of a Document (or somewhere within said contents), as the document&#39;s schema is required for YAML string output.</p>

<h4 style="clear:both"><code>new Map(), new Seq(), new Pair(key, value)</code></h4>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">YAML</span> <span class="nx">from</span> <span class="s1">'yaml'</span>
<span class="kr">import</span> <span class="nx">Pair</span> <span class="nx">from</span> <span class="s1">'yaml/pair'</span>
<span class="kr">import</span> <span class="nx">Seq</span> <span class="nx">from</span> <span class="s1">'yaml/seq'</span>

<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Seq</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s1">'some values'</span><span class="p">,</span>
  <span class="mi">42</span><span class="p">,</span>
  <span class="p">{</span> <span class="na">including</span><span class="p">:</span> <span class="s1">'objects'</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="s1">'a string'</span> <span class="p">}</span>
<span class="p">]</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">new</span> <span class="nx">Pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">'a number'</span><span class="p">))</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// - some values</span>
<span class="c1">// - 42</span>
<span class="c1">// - "3": a string</span>
<span class="c1">//   including: objects</span>
<span class="c1">// - 1: a number</span>
</code></pre>
<p>To construct a <code>Seq</code> or <code>Map</code>, use <a href="#yaml-createnode"><code>YAML.createNode()</code></a> with array, object or iterable input, or create the collections directly by importing the classes from <code>yaml/seq</code> and <code>yaml/map</code>.</p>

<p>Once created, normal array operations may be used to modify the <code>items</code> array. New <code>Pair</code> objects may created by importing the class from <code>yaml/pair</code> and using its <code>new Pair(key, value)</code> constructor.</p>
<h2 id='comments'>Comments</h2><pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s2">`
# This is YAML.
---
it has:
  - an array
  - of values
`</span><span class="p">)</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// { 'it has': [ 'an array', 'of values' ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">commentBefore</span>
<span class="c1">// ' This is YAML.'</span>

<span class="kr">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="s1">' item comment'</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">comment</span> <span class="o">=</span> <span class="s1">' collection end comment'</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// # This is YAML.</span>
<span class="c1">//</span>
<span class="c1">// it has:</span>
<span class="c1">//   - an array # item comment</span>
<span class="c1">//   - of values</span>
<span class="c1">//   # collection end comment</span>
</code></pre>
<p>A primary differentiator between this and other YAML libraries is the ability to programmatically handle comments, which according to <a href="http://yaml.org/spec/1.2/spec.html#id2767100">the spec</a> &quot;must not have any effect on the serialization tree or representation graph. In particular, comments are not associated with a particular node.&quot;</p>

<p>This library does allow comments to be handled programmatically, and does attach them to particular nodes (most often, the following node). Each <code>Scalar</code>, <code>Map</code>, <code>Seq</code> and the <code>Document</code> itself has <code>comment</code> and <code>commentBefore</code> members that may be set to a stringifiable value.</p>

<p>The string contents of comments are not processed by the library, except for merging adjacent comment lines together and prefixing each line with the <code>#</code> comment indicator. Document comments will be separated from the rest of the document by a blank line.</p>

<p><strong>Note</strong>: Due to implementation details, the library&#39;s comment handling is not completely stable. In particular, when creating, writing, and then reading a YAML file, comments may sometimes be associated with a different node.</p>
<h2 id='blank-lines'>Blank Lines</h2><pre class="highlight javascript"><code><span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s1">'[ one, two, three ]'</span><span class="p">)</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="s1">' item comment'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">spaceBefore</span> <span class="o">=</span> <span class="kc">true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">comment</span> <span class="o">=</span> <span class="s1">' document end comment'</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// [</span>
<span class="c1">//   one, # item comment</span>
<span class="c1">//</span>
<span class="c1">//   two,</span>
<span class="c1">//   three</span>
<span class="c1">// ]</span>
<span class="c1">//</span>
<span class="c1">// # document end comment</span>
</code></pre>
<p>Similarly to comments, the YAML spec instructs non-content blank lines to be discarded. Instead of doing that, <code>yaml</code> provides a <code>spaceBefore</code> boolean property for each node. If true, the node (and its <code>commentBefore</code>, if any) will be separated from the preceding node by a blank line.</p>

<p>Note that scalar block values with &quot;keep&quot; chomping (i.e. with <code>+</code> in their header) consider any trailing empty lines to be a part of their content, so the <code>spaceBefore</code> setting of a node following such a value is ignored.</p>
<h1 id='custom-data-types'>Custom Data Types</h1><pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">binary</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'yaml/types/binary'</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">timestamp</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'yaml/types/timestamp'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'!!timestamp 2001-12-15 2:59:43'</span><span class="p">)</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:yaml.org,2002:timestamp is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:str</span>
<span class="c1">// '2001-12-15 2:59:43'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">tags</span> <span class="o">=</span> <span class="p">[</span><span class="nx">binary</span><span class="p">,</span> <span class="nx">timestamp</span><span class="p">]</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'2001-12-15 2:59:43'</span><span class="p">)</span>
<span class="c1">// 2001-12-15T02:59:43.000Z</span>

<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s1">'2001-12-15 2:59:43'</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">toDateString</span><span class="p">()</span>
<span class="c1">// 'Sat Dec 15 2001'</span>
</code></pre>
<p>The easiest way to extend a <a href="#data-schemas">schema</a> is by defining the additional <strong>tags</strong> that you wish to support. For further customisation, <code>tags</code> may also be a function <code>(Tag[]) =&gt; (Tag[])</code> that may modify the schema&#39;s base tag array.</p>

<p>YAML 1.1 tags are available as exports under <code>yaml/types/</code>, should you wish to use them with the YAML 1.2 <code>core</code> schema.</p>
<h2 id='writing-custom-tags'>Writing Custom Tags</h2><pre class="highlight javascript"><code><span class="kr">import</span> <span class="p">{</span> <span class="nx">stringify</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">'yaml/schema'</span>

<span class="kr">const</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">identify</span><span class="p">:</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">RegExp</span><span class="p">,</span>
  <span class="na">tag</span><span class="p">:</span> <span class="s1">'!re'</span><span class="p">,</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">cst</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">cst</span><span class="p">.</span><span class="nx">strValue</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">\/([\s\S]</span><span class="sr">+</span><span class="se">)\/([</span><span class="sr">gimuy</span><span class="se">]</span><span class="sr">*</span><span class="se">)</span><span class="sr">$/</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">sharedSymbol</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">identify</span><span class="p">:</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span><span class="p">.</span><span class="nx">constructor</span> <span class="o">===</span> <span class="nx">Symbol</span><span class="p">,</span>
  <span class="na">tag</span><span class="p">:</span> <span class="s1">'!symbol/shared'</span><span class="p">,</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">cst</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="nx">cst</span><span class="p">.</span><span class="nx">strValue</span><span class="p">),</span>
  <span class="nx">stringify</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">onComment</span><span class="p">,</span> <span class="nx">onChompKeep</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'Only shared symbols are supported'</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">stringify</span><span class="p">({</span> <span class="na">value</span><span class="p">:</span> <span class="nx">key</span> <span class="p">},</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">onComment</span><span class="p">,</span> <span class="nx">onChompKeep</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">tags</span> <span class="o">=</span> <span class="p">[</span><span class="nx">regexp</span><span class="p">,</span> <span class="nx">sharedSymbol</span><span class="p">]</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">regexp</span><span class="p">:</span> <span class="sr">/foo/gi</span><span class="p">,</span>
  <span class="na">symbol</span><span class="p">:</span> <span class="nx">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// regexp: !re /foo/gi</span>
<span class="c1">// symbol: !symbol/shared bar</span>
</code></pre>
<p>In YAML-speak, a custom data type is represented by a <em>tag</em>. The default tags are mostly stringified with <em>implicit</em> tags, meaning that their type is detected automatically when parsing. Custom tags, on the other hand, are mostly <em>explicit</em>, meaning that they are prefixed with a local <code>!tag</code>, a shorthand <code>!ns!tag</code>, or a verbatim <code>!&lt;tag:example.com,2019:tag&gt;</code>.</p>

<p>To define your own tag, you&#39;ll need to define three or four things:</p>

<ol>
<li><strong><code>identify(value): boolean</code></strong> is used by <code>YAML.createNode</code> to detect your data type, e.g. using <code>typeof</code> or <code>instanceof</code>.</li>
<li><strong><code>tag</code></strong> is the string identifier for your data type, with which its stringified form will be prefixed. Should either be a !-prefixed local <code>!tag</code>, or a fully qualified <code>tag:domain,date:foo</code>.</li>
<li><strong><code>resolve(doc, cst): any</code></strong> turns a <code>cst</code> node into its encoded value; <code>doc</code> is the resulting <code>YAML.Document</code> instance.</li>
<li><strong><code>stringify(item, ctx, onComment, onChompKeep): string</code></strong> is an optional function stringifying the <code>item</code> AST node in the current context <code>ctx</code>. <code>onComment</code> and <code>onChompKeep</code> are callback functions for a couple of special cases. If your data includes a suitable <code>.toString()</code> method, you can probably leave this undefined and use the default stringifier.</li>
</ol>

<p>If you wish to implement your own custom tags, the <a href="https://github.com/eemeli/yaml/blob/master/src/schema/_binary.js"><code>!!binary</code></a> and <a href="https://github.com/eemeli/yaml/blob/master/src/schema/_timestamp.js"><code>!!timestamp</code></a> tags provide relatively cohesive examples to study.</p>

<p>The default schema types also include a few additional properties:</p>

<ul>
<li><code>test</code> and <code>default</code> allow for values to be stringified without an explicit tag and detected using a regular expression. For most cases, it&#39;s unlikely that you&#39;ll actually want to use these, even if you first think you do.</li>
<li><code>createNode</code> is an optional factory function, used e.g. by collections. If set, will be called as <code>createNode(schema, value, wrapScalars)</code> and should return a class extending <code>Node</code>.</li>
<li><code>nodeClass</code> is the <code>Node</code> child class that implements this tag. Required for collections and tags that have overlapping JS representations.</li>
<li>If a tag has multiple forms that should be parsed and/or stringified differently, use <code>format</code> to identify them.</li>
<li><code>options</code> are used by some tags to configure their stringification.</li>
</ul>
<h1 id='cst-parser'>CST Parser</h1>
<p>For ease of implementation and to provide better error handling and reporting, the lowest level of the library&#39;s parser turns any input string into a <a href="https://en.wikipedia.org/wiki/Concrete_syntax_tree"><strong>Concrete Syntax Tree</strong></a> of nodes as if the input were YAML. This level of the API has not been designed to be particularly user-friendly for external users, but it is fast, robust, and not dependent on the rest of the library.</p>
<h2 id='parsecst'>parseCST</h2><pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">parseCST</span> <span class="nx">from</span> <span class="s1">'yaml/parse-cst'</span>

<span class="kr">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">parseCST</span><span class="p">(</span><span class="s2">`
sequence: [ one, two, ]
mapping: { sky: blue, sea: green }
---
-
  "flow in block"
- &gt;
 Block scalar
- !!map # Block collection
  foo : bar
`</span><span class="p">)</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            <span class="c1">// first document, containing a map with two keys</span>
  <span class="p">.</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">// document contents (as opposed to directives)</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">node</span>  <span class="c1">// the last item, a flow map</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>       <span class="c1">// the fourth token, parsed as a plain value</span>
  <span class="p">.</span><span class="nx">strValue</span>       <span class="c1">// 'blue'</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>            <span class="c1">// second document, containing a sequence</span>
  <span class="p">.</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">// document contents (as opposed to directives)</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">node</span>  <span class="c1">// the second item, a block value</span>
  <span class="p">.</span><span class="nx">strValue</span>       <span class="c1">// 'Block scalar\n'</span>
</code></pre><h4 id='parsecst-string-cstdocument'><code>parseCST(string): CSTDocument[]</code></h4><h4 id='yaml-parsecst-string-cstdocument'><code>YAML.parseCST(string): CSTDocument[]</code></h4>
<p>The CST parser will not produce a CST that is necessarily valid YAML, and in particular its representation of collections of items is expected to undergo further processing and validation. The parser should never throw errors, but may include them as a value of the relevant node. On the other hand, if you feed it garbage, you&#39;ll likely get a garbage CST as well.</p>

<p>The public API of the CST layer is a single function which returns an array of parsed CST documents. The array and its contained nodes override the default <code>toString</code> method, each returning a YAML string representation of its contents. The same function is exported as a part of the default <code>YAML</code> object, as well as seprately at <code>yaml/parse-cst</code>. It has no dependency on the rest of the library, so importing only <code>parseCST</code> should add about 9kB to your gzipped bundle size, when the whole library will add about 27kB.</p>

<p>Care should be taken when modifying the CST, as no error checks are included to verify that the resulting YAML is valid, or that e.g. indentation levels aren&#39;t broken. In other words, this is an engineering tool and you may hurt yourself. If you&#39;re looking to generate a brand new YAML document, see the section on <a href="#creating-documents">Creating Documents</a>.</p>

<p>For more usage examples and CST trees, have a look through the <a href="https://github.com/eemeli/yaml/tree/master/__tests__/cst">extensive test suite</a> included in the project&#39;s repository.</p>

<h3 style="clear:both">Error detection</h3>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">YAML</span> <span class="nx">from</span> <span class="s1">'yaml'</span>

<span class="kr">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseCST</span><span class="p">(</span><span class="s1">'this: is: bad YAML'</span><span class="p">)</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1">// Note: Simplified for clarity</span>
<span class="c1">// { type: 'MAP',</span>
<span class="c1">//   items: [</span>
<span class="c1">//     { type: 'PLAIN', strValue: 'this' },</span>
<span class="c1">//     { type: 'MAP_VALUE',</span>
<span class="c1">//       node: {</span>
<span class="c1">//         type: 'MAP',</span>
<span class="c1">//         items: [</span>
<span class="c1">//           { type: 'PLAIN', strValue: 'is' },</span>
<span class="c1">//           { type: 'MAP_VALUE',</span>
<span class="c1">//             node: { type: 'PLAIN', strValue: 'bad YAML' } } ] } } ] }</span>

<span class="kr">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">errors</span>
<span class="c1">// [ {</span>
<span class="c1">//   name: 'YAMLSemanticError',</span>
<span class="c1">//   message: 'Nested mappings are not allowed in compact mappings',</span>
<span class="c1">//   source: {</span>
<span class="c1">//     type: 'MAP',</span>
<span class="c1">//     range: { start: 6, end: 18 },</span>
<span class="c1">//     ...,</span>
<span class="c1">//     rawValue: 'is: bad YAML' } } ]</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">.</span><span class="nx">value</span>
<span class="c1">// 'bad YAML'</span>
</code></pre>
<p>While the YAML spec considers e.g. block collections within a flow collection to be an error, this error will not be detected by the CST parser. For complete validation, you will need to parse the CST into a <code>YAML.Document</code>. If the document contains errors, they will be included in the document&#39;s <code>errors</code> array, and each error will will contain a <code>source</code> reference to the CST node where it was encountered. Do note that even if an error is encountered, the document contents might still be available. In such a case, the error will be a <a href="#yamlsemanticerror"><code>YAMLSemanticError</code></a> rather than a <a href="#yamlsyntaxerror"><code>YAMLSyntaxError</code></a>.</p>

<h3 style="clear:both">Dealing with CRLF line terminators</h3>
<pre class="highlight javascript"><code><span class="kr">import</span> <span class="nx">parseCST</span> <span class="nx">from</span> <span class="s1">'yaml/parse-cst'</span>

<span class="kr">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="s1">'- foo\r\n- bar\r\n'</span>
<span class="kr">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">parseCST</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="nx">cst</span><span class="p">.</span><span class="nx">setOrigRanges</span><span class="p">()</span> <span class="c1">// true</span>
<span class="kr">const</span> <span class="p">{</span> <span class="nx">range</span><span class="p">,</span> <span class="nx">valueRange</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">node</span>

<span class="nx">src</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">range</span><span class="p">.</span><span class="nx">origStart</span><span class="p">,</span> <span class="nx">range</span><span class="p">.</span><span class="nx">origEnd</span><span class="p">)</span>
<span class="c1">// 'bar\r\n'</span>

<span class="nx">src</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">valueRange</span><span class="p">.</span><span class="nx">origStart</span><span class="p">,</span> <span class="nx">valueRange</span><span class="p">.</span><span class="nx">origEnd</span><span class="p">)</span>
<span class="c1">// 'bar'</span>
</code></pre><h4 id='cst-setorigranges-bool'><code>CST#setOrigRanges(): bool</code></h4>
<p>The array returned by <code>parseCST()</code> will also include a method <code>setOrigRanges</code> to help deal with input that includes <code>\r\n</code> line terminators, which are converted to just <code>\n</code> before parsing into documents. This conversion will obviously change the total length of the string, as well as the offsets of all ranges. If the method returns <code>false</code>, the input did not include <code>\r\n</code> line terminators and no changes were made. However, if the method returns <code>true</code>, each <code>Range</code> object within the CST will have its <code>origStart</code> and <code>origEnd</code> values set appropriately to refer to the original input string.</p>
<h2 id='cst-nodes'>CST Nodes</h2>
<blockquote>
<p>Node type definitions use Flow-ish notation, so <code>+</code> as a prefix indicates a read-only getter property.</p>
</blockquote>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Range</span> <span class="p">{</span>
  <span class="nl">start</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>        <span class="c1">// offset of first character</span>
  <span class="nx">end</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>          <span class="c1">// offset after last character</span>
  <span class="nx">isEmpty</span><span class="p">():</span> <span class="kr">boolean</span><span class="p">,</span>   <span class="c1">// true if end is not greater than start</span>
  <span class="nx">origStart</span><span class="p">:</span> <span class="p">?</span><span class="nx">number</span><span class="p">,</span>   <span class="c1">// set by CST#setOrigRanges(), source</span>
  <span class="nx">origEnd</span><span class="p">:</span> <span class="p">?</span><span class="nx">number</span>      <span class="c1">//   offsets for input with CRLF terminators</span>
<span class="p">}</span>
</code></pre>
<p><strong>Note</strong>: The <code>Node</code>, <code>Scalar</code> and other values referred to in this section are the CST representations of said objects, and are not the same as those used in preceding parts.</p>

<p>Actual values in the CST nodes are stored as <code>start</code>, <code>end</code> indices of the input string. This allows for memory consumption to be minimised by making string generation really lazy.</p>

<h3 style="clear:both">Node</h3>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">context</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">atLineStart</span><span class="p">:</span> <span class="kr">boolean</span><span class="p">,</span> <span class="c1">// is this node the first one on this line</span>
    <span class="nx">indent</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>     <span class="c1">// current level of indentation (may be -1)</span>
    <span class="nx">root</span><span class="p">:</span> <span class="nx">CSTDocument</span><span class="p">,</span>  <span class="c1">// a reference to the parent document</span>
    <span class="nx">src</span><span class="p">:</span> <span class="nx">string</span>         <span class="c1">// the full original source</span>
  <span class="p">},</span>
  <span class="nx">error</span><span class="p">:</span> <span class="p">?</span><span class="nb">Error</span><span class="p">,</span>        <span class="c1">// if not null, indicates a parser failure</span>
  <span class="nx">props</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Range</span><span class="o">&gt;</span><span class="p">,</span>  <span class="c1">// anchors, tags and comments</span>
  <span class="nx">range</span><span class="p">:</span> <span class="nx">Range</span><span class="p">,</span>         <span class="c1">// span of context.src parsed into this node</span>
  <span class="nx">type</span><span class="p">:</span>                 <span class="c1">// specific node type</span>
    <span class="s1">'ALIAS'</span> <span class="o">|</span> <span class="s1">'BLOCK_FOLDED'</span> <span class="o">|</span> <span class="s1">'BLOCK_LITERAL'</span> <span class="o">|</span> <span class="s1">'COMMENT'</span> <span class="o">|</span>
    <span class="s1">'DIRECTIVE'</span> <span class="o">|</span> <span class="s1">'DOCUMENT'</span> <span class="o">|</span> <span class="s1">'FLOW_MAP'</span> <span class="o">|</span> <span class="s1">'FLOW_SEQ'</span> <span class="o">|</span>
    <span class="s1">'MAP'</span> <span class="o">|</span> <span class="s1">'MAP_KEY'</span> <span class="o">|</span> <span class="s1">'MAP_VALUE'</span> <span class="o">|</span> <span class="s1">'PLAIN'</span> <span class="o">|</span>
    <span class="s1">'QUOTE_DOUBLE'</span> <span class="o">|</span> <span class="s1">'QUOTE_SINGLE'</span> <span class="o">|</span> <span class="s1">'SEQ'</span> <span class="o">|</span> <span class="s1">'SEQ_ITEM'</span><span class="p">,</span>
  <span class="nx">value</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span>        <span class="c1">// if set to a non-null value, overrides</span>
                        <span class="c1">//   source value when stringified</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>     <span class="c1">// anchor, if set</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>    <span class="c1">// newline-delimited comment(s), if any</span>
  <span class="o">+</span><span class="nx">rangeAsLinePos</span><span class="p">:</span>      <span class="c1">// human-friendly source location</span>
    <span class="p">?{</span> <span class="na">start</span><span class="p">:</span> <span class="nx">LinePos</span><span class="p">,</span> <span class="na">end</span><span class="p">:</span> <span class="p">?</span><span class="nx">LinePos</span> <span class="p">},</span>
    <span class="c1">// LinePos here is { line: number, col: number }</span>
  <span class="o">+</span><span class="nx">rawValue</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>   <span class="c1">// an unprocessed slice of context.src</span>
                        <span class="c1">//   determining this node's value</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span>                 <span class="c1">// this node's tag, if set</span>
    <span class="kc">null</span> <span class="o">|</span> <span class="p">{</span> <span class="na">verbatim</span><span class="p">:</span> <span class="nx">string</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">handle</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="na">suffix</span><span class="p">:</span> <span class="nx">string</span> <span class="p">},</span>
  <span class="nx">toString</span><span class="p">():</span> <span class="nx">string</span>    <span class="c1">// a YAML string representation of this node</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">ContentNode</span> <span class="o">=</span>
  <span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">Map</span> <span class="o">|</span> <span class="nx">Seq</span> <span class="o">|</span> <span class="nx">FlowCollection</span>
</code></pre>
<p>Each node in the CST extends a common ancestor <code>Node</code>. Additional undocumented properties are available, but are likely only useful during parsing.</p>

<p>If a node has its <code>value</code> set, that will be used when re-stringifying (initially <code>undefined</code> for all nodes).</p>

<h3 style="clear:both">Scalars</h3>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Alias</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="c1">// rawValue will contain the anchor without the * prefix</span>
  <span class="nl">type</span><span class="p">:</span> <span class="s1">'ALIAS'</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Scalar</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="s1">'PLAIN'</span> <span class="o">|</span> <span class="s1">'QUOTE_DOUBLE'</span> <span class="o">|</span> <span class="s1">'QUOTE_SINGLE'</span> <span class="o">|</span>
    <span class="s1">'BLOCK_FOLDED'</span> <span class="o">|</span> <span class="s1">'BLOCK_LITERAL'</span>
  <span class="o">+</span><span class="nx">strValue</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span> <span class="o">|</span>  <span class="c1">// unescaped string value</span>
    <span class="p">{</span> <span class="na">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="na">errors</span><span class="p">:</span> <span class="nx">YAMLSyntaxError</span><span class="p">[]</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Comment</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="s1">'COMMENT'</span><span class="p">,</span>      <span class="c1">// PLAIN nodes may also be comment-only</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">rawValue</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">BlankLine</span> <span class="kr">extends</span> <span class="nx">Comment</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="s1">'BLANK_LINE'</span><span class="p">,</span>   <span class="c1">// may represent multiple consecutive empty</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>       <span class="c1">//   lines, which may include whitespace</span>
<span class="p">}</span>
</code></pre>
<p>While <code>Alias</code>, <code>BlankLine</code> and <code>Comment</code> nodes are not technically scalars, they are parsed as such at this level.</p>

<p>Due to parsing differences, each scalar type is implemented using its own class.</p>

<h3 style="clear:both">Collections</h3>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">MapItem</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">node</span><span class="p">:</span> <span class="nx">ContentNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'MAP_KEY'</span> <span class="o">|</span> <span class="s1">'MAP_VALUE'</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Map</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="c1">// implicit keys are not wrapped</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">MapItem</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'MAP'</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">SeqItem</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">node</span><span class="p">:</span> <span class="nx">ContentNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'SEQ_ITEM'</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Seq</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">SeqItem</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'SEQ'</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">FlowChar</span> <span class="o">=</span> <span class="s1">'{'</span> <span class="o">|</span> <span class="s1">'}'</span> <span class="o">|</span> <span class="s1">'['</span> <span class="o">|</span> <span class="s1">']'</span> <span class="o">|</span> <span class="s1">','</span> <span class="o">|</span> <span class="s1">'?'</span> <span class="o">|</span> <span class="s1">':'</span>

<span class="kr">class</span> <span class="nx">FlowCollection</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">FlowChar</span> <span class="o">|</span> <span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">FlowCollection</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'FLOW_MAP'</span> <span class="o">|</span> <span class="s1">'FLOW_SEQ'</span>
<span class="p">}</span>
</code></pre>
<p>Block and flow collections are parsed rather differently, due to their representation differences.</p>

<p>An <code>Alias</code> or <code>Scalar</code> item directly within a <code>Map</code> should be treated as an implicit map key.</p>

<p>In actual code, <code>MapItem</code> and <code>SeqItem</code> are implemented as <code>CollectionItem</code>, and correspondingly <code>Map</code> and <code>Seq</code> as <code>Collection</code>.</p>

<h3 style="clear:both">Document Structure</h3>
<pre class="highlight javascript"><code><span class="kr">class</span> <span class="nx">Directive</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>  <span class="c1">// should only be 'TAG' or 'YAML'</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'DIRECTIVE'</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">parameters</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">CSTDocument</span> <span class="kr">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">directives</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Directive</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">contents</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ContentNode</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="s1">'DOCUMENT'</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
</code></pre>
<p>The CST tree of a valid YAML document should have a single non-<code>Comment</code> <code>ContentNode</code> in its <code>contents</code> array. Multiple values indicates that the input is malformed in a way that made it impossible to determine the proper structure of the document.</p>
<h1 id='errors'>Errors</h1>
<p>All errors and warnings produced by the <code>yaml</code> parser functions contain the following fields:</p>

<table><thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>name</td>
<td><code>string</code></td>
<td>One of <code>YAMLReferenceError</code>, <code>YAMLSemanticError</code>, <code>YAMLSyntaxError</code>, or <code>YAMLWarning</code></td>
</tr>
<tr>
<td>message</td>
<td><code>string</code></td>
<td>A human-readable description of the error</td>
</tr>
<tr>
<td>source</td>
<td><code>CST Node</code></td>
<td>The CST node at which this error or warning was encountered</td>
</tr>
</tbody></table>
<h2 id='yamlreferenceerror'>YAMLReferenceError</h2>
<p>An error resolving a tag or an anchor that is referred to in the source. It is likely that the contents of the <code>source</code> node have not been completely parsed into the document. Not used by the CST parser.</p>
<h2 id='yamlsemanticerror'>YAMLSemanticError</h2>
<p>An error related to the metadata of the document, or an error with limitations imposed by the YAML spec. The data contents of the document should be valid, but the metadata may be broken.</p>
<h2 id='yamlsyntaxerror'>YAMLSyntaxError</h2>
<p>A serious parsing error; the document contents will not be complete, and the CST is likely to be rather broken.</p>
<h2 id='yamlwarning'>YAMLWarning</h2>
<p>Not an error, but a spec-mandated warning about unsupported directives or a fallback resolution being used for a node with an unavailable tag. Not used by the CST parser.</p>
<h1 id='yaml-syntax'>YAML Syntax</h1>
<p>A YAML <em>schema</em> is a combination of a set of tags and a mechanism for resolving non-specific tags, i.e. values that do not have an explicit tag such as <code>!!int</code>. The <a href="#data-schemas">default schema</a> is the <code>&#39;core&#39;</code> schema, which is the recommended one for YAML 1.2. For YAML 1.0 and YAML 1.1 documents the default is <code>&#39;yaml-1.1&#39;</code>.</p>
<h2 id='tags'>Tags</h2><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'"42"'</span><span class="p">)</span>
<span class="c1">// '42'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s1">'!!int "42"'</span><span class="p">)</span>
<span class="c1">// 42</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">`
%TAG ! tag:example.com,2018:app/
---
!foo 42
`</span><span class="p">)</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:example.com,2018:app/foo is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:str</span>
<span class="c1">// '42'</span>
</code></pre>
<p>The default prefix for YAML tags is <code>tag:yaml.org,2002:</code>, for which the shorthand <code>!!</code> is used when stringified. Shorthands for other prefixes may also be defined by document-specific directives, e.g. <code>!e!</code> or just <code>!</code> for <code>tag:example.com,2018:app/</code>, but this is not required to use a tag with a different prefix.</p>

<p>During parsing, unresolved tags should not result in errors (though they will be noted as <code>warnings</code>), with the tagged value being parsed according to the data type that it would have under automatic tag resolution rules. This should not result in any data loss, allowing such tags to be handled by the calling app.</p>

<p>In order to have <code>yaml</code> provide you with automatic parsing and stringification of non-standard data types, it will need to be configured with a suitable tag object. For more information, see <a href="#custom-tags">Custom Tags</a>.</p>

<p>The YAML 1.0 tag specification is <a href="#changes-from-yaml-1-0-to-1-1">slightly different</a> from that used in later versions, and implements prefixing shorthands rather differently.</p>
<h2 id='version-differences'>Version Differences</h2>
<p>This library&#39;s parser is based on the 1.2 version of the <a href="http://yaml.org/spec/1.2/spec.html">YAML spec</a>, which is mostly backwards-compatible with <a href="http://yaml.org/spec/1.1/">YAML 1.1</a> as well as <a href="http://yaml.org/spec/1.0/">YAML 1.0</a>. Some specific relaxations have been added for backwards compatibility, but if you encounter an issue please <a href="https://github.com/eemeli/yaml/issues">report it</a>.</p>
<h3 id='changes-from-yaml-1-1-to-1-2'>Changes from YAML 1.1 to 1.2</h3><pre class="highlight yaml tab-yaml"><code><span class="nt">%YAML</span> <span class="m">1.1</span>
<span class="nn">---</span>
<span class="na">true</span><span class="pi">:</span> <span class="s">Yes</span>
<span class="na">octal</span><span class="pi">:</span> <span class="s">014</span>
<span class="na">sexagesimal</span><span class="pi">:</span> <span class="s">3:25:45</span>
<span class="na">picture</span><span class="pi">:</span> <span class="kt">!!binary</span> <span class="pi">|</span>
 <span class="no">R0lGODlhDAAMAIQAAP//9/X</span>
 <span class="no">17unp5WZmZgAAAOfn515eXv</span>
 <span class="no">Pz7Y6OjuDg4J+fn5OTk6enp</span>
 <span class="no">56enmleECcgggoBADs=</span>
</code></pre><pre class="highlight javascript"><code><span class="p">{</span> <span class="nl">true</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">octal</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
  <span class="nx">sexagesimal</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
  <span class="nx">picture</span><span class="p">:</span>
   <span class="nx">Buffer</span> <span class="p">[</span><span class="nx">Uint8Array</span><span class="p">]</span> <span class="p">[</span>
     <span class="mi">71</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
     <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">247</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">238</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span>
     <span class="mi">102</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">243</span><span class="p">,</span>
     <span class="mi">243</span><span class="p">,</span> <span class="mi">237</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span>
     <span class="mi">159</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span>
     <span class="mi">105</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span> <span class="p">]</span> <span class="p">}</span>
</code></pre>
<p>The most significant difference between YAML 1.1 and YAML 1.2 is the introduction of the core data schema as the recommended default, replacing the YAML 1.1 type library:</p>

<ul>
<li>Only <code>true</code> and <code>false</code> strings are parsed as booleans (including <code>True</code> and <code>TRUE</code>); <code>y</code>, <code>yes</code>, <code>on</code>, and their negative counterparts are parsed as strings.</li>
<li>Underlines <code>_</code> cannot be used within numerical values.</li>
<li>Octal values need a <code>0o</code> prefix; e.g. <code>010</code> is now parsed with the value 10 rather than 8.</li>
<li>The binary and sexagesimal integer formats have been dropped.</li>
<li>The <code>!!pairs</code>, <code>!!omap</code>, <code>!!set</code>, <code>!!timestamp</code> and <code>!!binary</code> types have been dropped.</li>
<li>The merge <code>&lt;&lt;</code> and value <code>=</code> special mapping keys have been removed.</li>
</ul>

<p>The other major change has been to make sure that YAML 1.2 is a valid superset of JSON. Additionally there are some minor differences between the parsing rules:</p>

<ul>
<li>The next-line <code>\x85</code>, line-separator <code>\u2028</code> and paragraph-separator <code>\u2029</code> characters are no longer considered line-break characters. Within scalar values, this means that next-line characters will not be included in the white-space normalisation. Using any of these outside scalar values is likely to result in errors during parsing. For a relatively robust solution, try replacing <code>\x85</code> and <code>\u2028</code> with <code>\n</code> and <code>\u2029</code> with <code>\n\n</code>.</li>
<li>Tag shorthands can no longer include any of the characters <code>,[]{}</code>, but can include <code>#</code>. To work around this, either fix your tag names or use verbatim tags.</li>
<li>Anchors can no longer include any of the characters <code>,[]{}</code>.</li>
<li>Inside double-quoted strings <code>\/</code> is now a valid escape for the <code>/</code> character.</li>
<li>Quoted content can include practically all Unicode characters</li>
</ul>
<h3 id='changes-from-yaml-1-0-to-1-1'>Changes from YAML 1.0 to 1.1</h3><pre class="highlight plaintext"><code>%YAML:1.0
---
date: 2001-01-23
number: !int '123'
string: !str 123
pool: !!ball { number: 8 }
invoice: !domain.tld,2002/^invoice
  customers: !seq
    - !^customer
      given : Chris
      family : Dumars
</code></pre><pre class="highlight javascript"><code><span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:private.yaml.org,2002:ball is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:domain.tld,2002/^invoice is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag ^customer is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="p">{</span> <span class="nl">date</span><span class="p">:</span> <span class="s1">'2001-01-23T00:00:00.000Z'</span><span class="p">,</span>
  <span class="nx">number</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">string</span><span class="p">:</span> <span class="s1">'123'</span><span class="p">,</span>
  <span class="nx">pool</span><span class="p">:</span> <span class="p">{</span> <span class="nl">number</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span>
  <span class="nx">invoice</span><span class="p">:</span> <span class="p">{</span> <span class="nl">customers</span><span class="p">:</span> <span class="p">[</span> <span class="p">{</span> <span class="na">given</span><span class="p">:</span> <span class="s1">'Chris'</span><span class="p">,</span> <span class="na">family</span><span class="p">:</span> <span class="s1">'Dumars'</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</code></pre>
<p>The most significant difference between these versions is the complete refactoring of the tag syntax:</p>

<ul>
<li>The <code>%TAG</code> directive has been added, along with the <code>!foo!</code> tag prefix shorthand notation.</li>
<li>The <code>^</code> character no longer enables tag prefixing.</li>
<li>The private vs. default scoping of <code>!</code> and <code>!!</code> tag prefixes has been switched around; <code>!!str</code> is now a default tag while <code>!bar</code> is an application-specific tag.</li>
<li>Verbatim <code>!&lt;baz&gt;</code> tag notation has been added.</li>
<li>The formal <code>tag:domain,date/path</code> format for tag names has been dropped as a requirement.</li>
</ul>

<p>Additionally, the formal description of the language describing the document structure has been completely refactored between these versions, but the described intent has not changed. Other changes include:</p>

<ul>
<li>A <code>\</code> escape has been added for the tab character, in addition to the pre-existing <code>\t</code></li>
<li>The <code>\^</code> escape has been removed</li>
<li>Directives now use a blank space <code>&#39; &#39;</code> rather than <code>:</code> as the separator between the name and its parameter/value.</li>
</ul>

<p><code>yaml</code> supports parsing and stringifying YAML 1.0 tags, but does not expand tags using the <code>^</code> notation. If this is something you&#39;d find useful, please file a <a href="https://github.com/eemeli/yaml/issues">GitHub issue</a> about it.</p>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
