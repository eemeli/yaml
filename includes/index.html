
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>YAML</title>
    <link href="../images/favicon.ico" rel="icon" type="image/ico" />

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
  background-color: #272822;
}
.highlight .nn {
  color: #ffffff;
  background-color: #272822;
}
.highlight .nl {
  color: #ffffff;
  background-color: #272822;
}
.highlight .ni {
  color: #ffffff;
  background-color: #272822;
}
.highlight .bp {
  color: #ffffff;
  background-color: #272822;
}
.highlight .vg {
  color: #ffffff;
  background-color: #272822;
}
.highlight .vi {
  color: #ffffff;
  background-color: #272822;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
  background-color: #272822;
}
.highlight .w {
  color: #ffffff;
  background-color: #272822;
}
.highlight {
  color: #ffffff;
  background-color: #272822;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
  background-color: #272822;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="../stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="../stylesheets/print.css" rel="stylesheet" media="print" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-126084011-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-126084011-1');
    </script>
      <script src="../javascripts/all.js"></script>
  </head>

  <body class="includes includes_index" data-languages="[]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="../images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="../images/logo.png" class="logo" alt="Logo" />
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#yaml" class="toc-h1 toc-link" data-title="YAML">YAML</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#api-overview" class="toc-h2 toc-link" data-title="API Overview">API Overview</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#parse-amp-stringify" class="toc-h1 toc-link" data-title="Parse &amp; Stringify">Parse &amp; Stringify</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#yaml-parse" class="toc-h2 toc-link" data-title="YAML.parse">YAML.parse</a>
                  </li>
                  <li>
                    <a href="#yaml-stringify" class="toc-h2 toc-link" data-title="YAML.stringify">YAML.stringify</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#options" class="toc-h1 toc-link" data-title="Options">Options</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#data-schemas" class="toc-h2 toc-link" data-title="Data Schemas">Data Schemas</a>
                  </li>
                  <li>
                    <a href="#scalar-options" class="toc-h2 toc-link" data-title="Scalar Options">Scalar Options</a>
                  </li>
                  <li>
                    <a href="#silencing-warnings" class="toc-h2 toc-link" data-title="Silencing Warnings">Silencing Warnings</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#documents" class="toc-h1 toc-link" data-title="Documents">Documents</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#parsing-documents" class="toc-h2 toc-link" data-title="Parsing Documents">Parsing Documents</a>
                  </li>
                  <li>
                    <a href="#creating-documents" class="toc-h2 toc-link" data-title="Creating Documents">Creating Documents</a>
                  </li>
                  <li>
                    <a href="#document-methods" class="toc-h2 toc-link" data-title="Document Methods">Document Methods</a>
                  </li>
                  <li>
                    <a href="#working-with-anchors" class="toc-h2 toc-link" data-title="Working with Anchors">Working with Anchors</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#content-nodes" class="toc-h1 toc-link" data-title="Content Nodes">Content Nodes</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#scalar-values" class="toc-h2 toc-link" data-title="Scalar Values">Scalar Values</a>
                  </li>
                  <li>
                    <a href="#collections" class="toc-h2 toc-link" data-title="Collections">Collections</a>
                  </li>
                  <li>
                    <a href="#alias-nodes" class="toc-h2 toc-link" data-title="Alias Nodes">Alias Nodes</a>
                  </li>
                  <li>
                    <a href="#creating-nodes" class="toc-h2 toc-link" data-title="Creating Nodes">Creating Nodes</a>
                  </li>
                  <li>
                    <a href="#comments" class="toc-h2 toc-link" data-title="Comments">Comments</a>
                  </li>
                  <li>
                    <a href="#blank-lines" class="toc-h2 toc-link" data-title="Blank Lines">Blank Lines</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#custom-data-types" class="toc-h1 toc-link" data-title="Custom Data Types">Custom Data Types</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#built-in-custom-tags" class="toc-h2 toc-link" data-title="Built-in Custom Tags">Built-in Custom Tags</a>
                  </li>
                  <li>
                    <a href="#writing-custom-tags" class="toc-h2 toc-link" data-title="Writing Custom Tags">Writing Custom Tags</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#cst-parser" class="toc-h1 toc-link" data-title="CST Parser">CST Parser</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#parsecst" class="toc-h2 toc-link" data-title="parseCST">parseCST</a>
                  </li>
                  <li>
                    <a href="#cst-nodes" class="toc-h2 toc-link" data-title="CST Nodes">CST Nodes</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#errors" class="toc-h1 toc-link" data-title="Errors">Errors</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#yamlreferenceerror" class="toc-h2 toc-link" data-title="YAMLReferenceError">YAMLReferenceError</a>
                  </li>
                  <li>
                    <a href="#yamlsemanticerror" class="toc-h2 toc-link" data-title="YAMLSemanticError">YAMLSemanticError</a>
                  </li>
                  <li>
                    <a href="#yamlsyntaxerror" class="toc-h2 toc-link" data-title="YAMLSyntaxError">YAMLSyntaxError</a>
                  </li>
                  <li>
                    <a href="#yamlwarning" class="toc-h2 toc-link" data-title="YAMLWarning">YAMLWarning</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#yaml-syntax" class="toc-h1 toc-link" data-title="YAML Syntax">YAML Syntax</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#tags" class="toc-h2 toc-link" data-title="Tags">Tags</a>
                  </li>
                  <li>
                    <a href="#version-differences" class="toc-h2 toc-link" data-title="Version Differences">Version Differences</a>
                  </li>
              </ul>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='https://github.com/eemeli/yaml/releases'>Version <span id='version'>2.x.y</span> (changelog)</a></li>
            <li><a href='https://github.com/eemeli/yaml'>github.com/eemeli/yaml</a></li>
            <li><a href='https://www.npmjs.com/package/yaml'><code>npm install yaml</code></a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='yaml'>YAML</h1>
<blockquote>
<p>To install:</p>
</blockquote>
<div class="highlight"><pre class="highlight sh tab-shell"><code>npm <span class="nb">install </span>yaml@next
<span class="c"># or</span>
yarn add yaml@next
</code></pre></div>
<p><code>yaml</code> is a new definitive library for <a href="http://yaml.org/">YAML</a>, a human friendly data serialization standard. This library:</p>

<ul>
<li>Supports all versions of the standard (1.0, 1.1, and 1.2),</li>
<li>Passes all of the <a href="https://github.com/yaml/yaml-test-suite">yaml-test-suite</a> tests,</li>
<li>Can accept any string as input without throwing, parsing as much YAML out of it as it can, and</li>
<li>Supports parsing, modifying, and writing YAML comments.</li>
</ul>

<p>The library is released under the ISC open source license, and the code is <a href="https://github.com/eemeli/yaml/">available on GitHub</a>. It has no external dependencies and runs on Node.js 6 and later, and in browsers from IE 11 upwards.</p>

<p>For the purposes of versioning, any changes that break any of the endpoints or APIs documented here will be considered semver-major breaking changes. Undocumented library internals may change between minor versions, and previous APIs may be deprecated (but not removed).</p>

<p><strong>Note:</strong> These docs are for <code>yaml@2</code>. For v1, see the <a href="https://github.com/eemeli/yaml/tree/v1.10.0">v1.10.0 tag</a> for the source and <a href="https://eemeli.org/yaml/v1/">eemeli.org/yaml/v1</a> for the documentation.</p>
<h2 id='api-overview'>API Overview</h2>
<p>The API provided by <code>yaml</code> has three layers, depending on how deep you need to go: <a href="#parse-amp-stringify">Parse &amp; Stringify</a>, <a href="#documents">Documents</a>, and the <a href="#cst-parser">CST Parser</a>. The first has the simplest API and &quot;just works&quot;, the second gets you all the bells and whistles supported by the library along with a decent <a href="#content-nodes">AST</a>, and the third is the closest to YAML source, making it fast, raw, and crude.</p>

<h3>Parse & Stringify</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">YAML</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>
<span class="c1">// or</span>
<span class="kd">const</span> <span class="nx">YAML</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div>
<ul>
<li><a href="#yaml-parse"><code>YAML.parse(str, reviver?, options?): value</code></a></li>
<li><a href="#yaml-stringify"><code>YAML.stringify(value, replacer?, options?): string</code></a></li>
</ul>

<h3>Documents</h3>

<ul>
<li><a href="#options"><code>YAML.defaultOptions</code></a></li>
<li><a href="#documents"><code>YAML.Document</code></a>

<ul>
<li><a href="#creating-documents"><code>constructor(value, replacer?, options?)</code></a></li>
<li><a href="#options"><code>defaults</code></a></li>
<li><a href="#creating-nodes"><code>#createNode(value, options?): Node</code></a></li>
<li><a href="#working-with-anchors"><code>#anchors</code></a></li>
<li><a href="#content-nodes"><code>#contents</code></a></li>
<li><a href="#errors"><code>#errors</code></a></li>
</ul></li>
<li><a href="#parsing-documents"><code>YAML.parseAllDocuments(str, options?): YAML.Document[]</code></a></li>
<li><a href="#parsing-documents"><code>YAML.parseDocument(str, options?): YAML.Document</code></a></li>
</ul>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Pair</span><span class="p">,</span> <span class="nx">YAMLMap</span><span class="p">,</span> <span class="nx">YAMLSeq</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/types</span><span class="dl">'</span>
</code></pre></div>
<ul>
<li><a href="#creating-nodes"><code>new Pair(key, value)</code></a></li>
<li><a href="#creating-nodes"><code>new YAMLMap()</code></a></li>
<li><a href="#creating-nodes"><code>new YAMLSeq()</code></a></li>
</ul>

<h3>CST Parser</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">parseCST</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/parse-cst</span><span class="dl">'</span>
</code></pre></div>
<ul>
<li><a href="#parsecst"><code>parseCST(str): CSTDocument[]</code></a></li>
<li><a href="#parsecst"><code>YAML.parseCST(str): CSTDocument[]</code></a></li>
</ul>
<h1 id='parse-amp-stringify'>Parse &amp; Stringify</h1><div class="highlight"><pre class="highlight yaml tab-yaml"><code><span class="c1"># file.yml</span>
<span class="na">YAML</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">A human-readable data serialization language</span>
  <span class="pi">-</span> <span class="s">https://en.wikipedia.org/wiki/YAML</span>
<span class="na">yaml</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">A complete JavaScript implementation</span>
  <span class="pi">-</span> <span class="s">https://www.npmjs.com/package/yaml</span>
</code></pre></div>
<p>At its simplest, you can use <code>YAML.parse(str)</code> and <code>YAML.stringify(value)</code> just as you&#39;d use <code>JSON.parse(str)</code> and <code>JSON.stringify(value)</code>. If that&#39;s enough for you, everything else in these docs is really just implementation details.</p>
<h2 id='yaml-parse'>YAML.parse</h2><div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">fs</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">YAML</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">3.14159</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// 3.14159</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ true, false, maybe, null ]</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// [ true, false, 'maybe', null ]</span>

<span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">./file.yml</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="c1">// { YAML:</span>
<span class="c1">//   [ 'A human-readable data serialization language',</span>
<span class="c1">//     'https://en.wikipedia.org/wiki/YAML' ],</span>
<span class="c1">//   yaml:</span>
<span class="c1">//   [ 'A complete JavaScript implementation',</span>
<span class="c1">//     'https://www.npmjs.com/package/yaml' ] }</span>
</code></pre></div><h4 id='yaml-parse-str-reviver-options-any'><code>YAML.parse(str, reviver?, options = {}): any</code></h4>
<p><code>str</code> should be a string with YAML formatting. If defined, the <code>reviver</code> function follows the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter">JSON implementation</a>. See <a href="#options">Options</a> for more information on the last argument, an optional configuration object.</p>

<p>The returned value will match the type of the root value of the parsed YAML document, so Maps become objects, Sequences arrays, and scalars result in nulls, booleans, numbers and strings.</p>

<p><code>YAML.parse</code> may throw on error, and it may log warnings using <code>console.warn</code>. It only supports input consisting of a single YAML document; for multi-document support you should use <a href="#parsing-documents"><code>YAML.parseAllDocuments</code></a>.</p>
<h2 id='yaml-stringify'>YAML.stringify</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="mf">3.14159</span><span class="p">)</span>
<span class="c1">// '3.14159\n'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">([</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="dl">'</span><span class="s1">maybe</span><span class="dl">'</span><span class="p">,</span> <span class="kc">null</span><span class="p">])</span>
<span class="c1">// `- true</span>
<span class="c1">// - false</span>
<span class="c1">// - maybe</span>
<span class="c1">// - null</span>
<span class="c1">// `</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">number</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">plain</span><span class="p">:</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">,</span> <span class="na">block</span><span class="p">:</span> <span class="dl">'</span><span class="s1">two</span><span class="se">\n</span><span class="s1">lines</span><span class="se">\n</span><span class="dl">'</span> <span class="p">})</span>
<span class="c1">// `number: 3</span>
<span class="c1">// plain: string</span>
<span class="c1">// block: &gt;</span>
<span class="c1">//   two</span>
<span class="c1">//</span>
<span class="c1">//   lines</span>
<span class="c1">// `</span>
</code></pre></div><h4 id='yaml-stringify-value-replacer-options-string'><code>YAML.stringify(value, replacer?, options = {}): string</code></h4>
<p><code>value</code> can be of any type. The returned string will always include <code>\n</code> as the last character, as is expected of YAML documents. If defined, the <code>replacer</code> array or function follows the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">JSON implementation</a>. See <a href="#options">Options</a> for more information on the last argument, an optional configuration object. For JSON compatibility, using a number or a string as the <code>options</code> value will set the <code>indent</code> option accordingly.</p>

<p>As strings in particular may be represented in a number of different styles, the simplest option for the value in question will always be chosen, depending mostly on the presence of escaped or control characters and leading &amp; trailing whitespace.</p>

<p>To create a stream of documents, you may call <code>YAML.stringify</code> separately for each document&#39;s <code>value</code>, and concatenate the documents with the string <code>...\n</code> as a separator.</p>
<h1 id='options'>Options</h1><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span>
<span class="c1">// { indent: 2,</span>
<span class="c1">//   keepNodeTypes: true,</span>
<span class="c1">//   mapAsMap: false,</span>
<span class="c1">//   version: '1.2' }</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">.</span><span class="nx">defaults</span>
<span class="c1">// { '1.0': { merge: true, schema: 'yaml-1.1' },</span>
<span class="c1">//   '1.1': { merge: true, schema: 'yaml-1.1' },</span>
<span class="c1">//   '1.2': { merge: false, schema: 'core' } }</span>
</code></pre></div><h4 id='yaml-defaultoptions'><code>YAML.defaultOptions</code></h4><h4 id='yaml-document-defaults'><code>YAML.Document.defaults</code></h4>
<p><code>yaml</code> defines document-specific options in three places: as an argument of parse, create and stringify calls, in the values of <code>YAML.defaultOptions</code>, and in the version-dependent <code>YAML.Document.defaults</code> object. Values set in <code>YAML.defaultOptions</code> override version-dependent defaults, and argument options override both.</p>

<p>The <code>version</code> option value (<code>&#39;1.2&#39;</code> by default) may be overridden by any document-specific <code>%YAML</code> directive.</p>

<table><thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>anchorPrefix</td>
<td><code>string</code></td>
<td>Default prefix for anchors. By default <code>&#39;a&#39;</code>, resulting in anchors <code>a1</code>, <code>a2</code>, etc.</td>
</tr>
<tr>
<td>customTags</td>
<td><code>Tag[] ⎮ function</code></td>
<td>Array of <a href="#custom-data-types">additional tags</a> to include in the schema</td>
</tr>
<tr>
<td>indent</td>
<td><code>number</code></td>
<td>The number of spaces to use when indenting code. By default <code>2</code>.</td>
</tr>
<tr>
<td>indentSeq</td>
<td><code>boolean</code></td>
<td>Whether block sequences should be indented. By default <code>true</code>.</td>
</tr>
<tr>
<td>keepCstNodes</td>
<td><code>boolean</code></td>
<td>Include references in the AST to each node&#39;s corresponding CST node. By default <code>false</code>.</td>
</tr>
<tr>
<td>keepNodeTypes</td>
<td><code>boolean</code></td>
<td>Store the original node type when parsing documents. By default <code>true</code>.</td>
</tr>
<tr>
<td>keepUndefined</td>
<td><code>boolean</code></td>
<td>Keep <code>undefined</code> object values when creating mappings and return a Scalar node when stringifying <code>undefined</code>. By default <code>false</code>.</td>
</tr>
<tr>
<td>mapAsMap</td>
<td><code>boolean</code></td>
<td>When outputting JS, use Map rather than Object to represent mappings. By default <code>false</code>.</td>
</tr>
<tr>
<td>maxAliasCount</td>
<td><code>number</code></td>
<td>Prevent <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">exponential entity expansion attacks</a> by limiting data aliasing count; set to <code>-1</code> to disable checks; <code>0</code> disallows all alias nodes. By default <code>100</code>.</td>
</tr>
<tr>
<td>merge</td>
<td><code>boolean</code></td>
<td>Enable support for <code>&lt;&lt;</code> merge keys. By default <code>false</code> for YAML 1.2 and <code>true</code> for earlier versions.</td>
</tr>
<tr>
<td>prettyErrors</td>
<td><code>boolean</code></td>
<td>Include line position &amp; node type directly in errors; drop their verbose source and context. By default <code>false</code>.</td>
</tr>
<tr>
<td>resolveKnownTags</td>
<td><code>boolean</code></td>
<td>When using the <code>&#39;core&#39;</code> schema, support parsing values with these explicit <a href="https://yaml.org/type/">YAML 1.1 tags</a>: <code>!!binary</code>, <code>!!omap</code>, <code>!!pairs</code>, <code>!!set</code>, <code>!!timestamp</code>. By default <code>true</code>.</td>
</tr>
<tr>
<td>schema</td>
<td><code>&#39;core&#39; ⎮ &#39;failsafe&#39; ⎮</code> <code>&#39;json&#39; ⎮ &#39;yaml-1.1&#39;</code></td>
<td>The base schema to use. By default <code>&#39;core&#39;</code> for YAML 1.2 and <code>&#39;yaml-1.1&#39;</code> for earlier versions.</td>
</tr>
<tr>
<td>simpleKeys</td>
<td><code>boolean</code></td>
<td>When stringifying, require keys to be scalars and to use implicit rather than explicit notation. By default <code>false</code>.</td>
</tr>
<tr>
<td>sortMapEntries</td>
<td><code>boolean ⎮</code> <code>(a, b: Pair) =&gt; number</code></td>
<td>When stringifying, sort map entries. If <code>true</code>, sort by comparing key values with <code>&lt;</code>. By default <code>false</code>.</td>
</tr>
<tr>
<td>version</td>
<td><code>&#39;1.0&#39; ⎮ &#39;1.1&#39; ⎮ &#39;1.2&#39;</code></td>
<td>The YAML version used by documents without a <code>%YAML</code> directive. By default <code>&#39;1.2&#39;</code>.</td>
</tr>
</tbody></table>
<h2 id='data-schemas'>Data Schemas</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 3</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failsafe</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// '3'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'No'</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">json</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// SyntaxError: Unresolved plain scalar "No"</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yaml-1.1</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// false</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">version</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1.1</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// false</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{[1, 2]: many}</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// { '[1,2]': 'many' }</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{[1, 2]: many}</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">mapAsMap</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="c1">// Map { [ 1, 2 ] =&gt; 'many' }</span>
</code></pre></div>
<p>Aside from defining the language structure, the YAML 1.2 spec defines a number of different <em>schemas</em> that may be used. The default is the <a href="http://yaml.org/spec/1.2/spec.html#id2804923"><code>core</code></a> schema, which is the most common one. The <a href="http://yaml.org/spec/1.2/spec.html#id2803231"><code>json</code></a> schema is effectively the minimum schema required to parse JSON; both it and the core schema are supersets of the minimal <a href="http://yaml.org/spec/1.2/spec.html#id2802346"><code>failsafe</code></a> schema.</p>

<p>The <code>yaml-1.1</code> schema matches the more liberal <a href="http://yaml.org/type/">YAML 1.1 types</a> (also used by YAML 1.0), including binary data and timestamps as distinct tags as well as accepting greater variance in scalar values (with e.g. <code>&#39;No&#39;</code> being parsed as <code>false</code> rather than a string value). The <code>!!value</code> and <code>!!yaml</code> types are not supported.</p>
<div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">merge</span> <span class="o">=</span> <span class="kc">true</span>

<span class="kd">const</span> <span class="nx">mergeResult</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">`
source: &amp;base { a: 1, b: 2 }
target:
  &lt;&lt;: *base
  b: base
`</span><span class="p">)</span>

<span class="nx">mergeResult</span><span class="p">.</span><span class="nx">target</span>
<span class="c1">// { a: 1, b: 'base' }</span>
</code></pre></div>
<p><strong>Merge</strong> keys are a <a href="http://yaml.org/type/merge.html">YAML 1.1 feature</a> that is not a part of the 1.2 spec. To use a merge key, assign an alias node or an array of alias nodes as the value of a <code>&lt;&lt;</code> key in a mapping.</p>
<h2 id='scalar-options'>Scalar Options</h2><div class="highlight"><pre class="highlight javascript"><code><span class="c1">// Without simpleKeys, an all-null-values object uses explicit keys &amp; no values</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="dl">'</span><span class="s1">this is</span><span class="dl">'</span><span class="p">:</span> <span class="kc">null</span> <span class="p">},</span> <span class="p">{</span> <span class="na">simpleKeys</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
<span class="c1">// this is: null</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">scalarOptions</span><span class="p">.</span><span class="kc">null</span><span class="p">.</span><span class="nx">nullStr</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">~</span><span class="dl">'</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">scalarOptions</span><span class="p">.</span><span class="nx">str</span><span class="p">.</span><span class="nx">defaultType</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">this</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">that</span><span class="p">:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="p">})</span>
<span class="c1">// this: ~</span>
<span class="c1">// that: 'value'</span>
</code></pre></div><h4 id='yaml-scalaroptions'><code>YAML.scalarOptions</code></h4>
<p>Some customization options are availabe to control the parsing and stringification of scalars. Note that these values are used by all documents.</p>

<p>These options objects are also exported individually from <code>&#39;yaml/types&#39;</code>.</p>

<table><thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Default value</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>binary.defaultType</td>
<td><code>Type</code></td>
<td><code>&#39;BLOCK_LITERAL&#39;</code></td>
<td>The type of string literal used to stringify <code>!!binary</code> values</td>
</tr>
<tr>
<td>binary.lineWidth</td>
<td><code>number</code></td>
<td><code>76</code></td>
<td>Maximum line width for <code>!!binary</code> values</td>
</tr>
<tr>
<td>bool.trueStr</td>
<td><code>string</code></td>
<td><code>&#39;true&#39;</code></td>
<td>String representation for <code>true</code> values</td>
</tr>
<tr>
<td>bool.falseStr</td>
<td><code>string</code></td>
<td><code>&#39;false&#39;</code></td>
<td>String representation for <code>false</code> values</td>
</tr>
<tr>
<td>int.asBigInt</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Whether integers should be parsed into <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a> values</td>
</tr>
<tr>
<td>null.nullStr</td>
<td><code>string</code></td>
<td><code>&#39;null&#39;</code></td>
<td>String representation for <code>null</code> values</td>
</tr>
<tr>
<td>str.defaultType</td>
<td><code>Type</code></td>
<td><code>&#39;PLAIN&#39;</code></td>
<td>The default type of string literal used to stringify values in general</td>
</tr>
<tr>
<td>str.defaultKeyType</td>
<td><code>Type</code></td>
<td><code>&#39;PLAIN&#39;</code></td>
<td>The default type of string literal used to stringify implicit key values</td>
</tr>
<tr>
<td>str.doubleQuoted</td>
<td><code>object</code></td>
<td><code>{ jsonEncoding: false,</code> <code>minMultiLineLength: 40 }</code></td>
<td><code>jsonEncoding</code>: Whether to restrict double-quoted strings to use JSON-compatible syntax; <code>minMultiLineLength</code>: Minimum length to use multiple lines to represent the value</td>
</tr>
<tr>
<td>str.fold</td>
<td><code>object</code></td>
<td><code>{ lineWidth: 80,</code> <code>minContentWidth: 20 }</code></td>
<td><code>lineWidth</code>: Maximum line width (set to <code>0</code> to disable folding); <code>minContentWidth</code>: Minimum width for highly-indented content</td>
</tr>
</tbody></table>
<h2 id='silencing-warnings'>Silencing Warnings</h2>
<p>By default, the library will emit warnings as required by the YAML spec during parsing. If you&#39;d like to silence these, define a global or <code>process.env</code> variable <code>YAML_SILENCE_WARNINGS</code> with a true-ish value.</p>
<h1 id='documents'>Documents</h1>
<p>In order to work with YAML features not directly supported by native JavaScript data types, such as comments, anchors and aliases, <code>yaml</code> provides the <code>YAML.Document</code> API.</p>
<h2 id='parsing-documents'>Parsing Documents</h2><div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">fs</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">fs</span><span class="dl">'</span>
<span class="k">import</span> <span class="nx">YAML</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">file</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">./file.yml</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">utf8</span><span class="dl">'</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">file</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span>
<span class="c1">// YAMLMap {</span>
<span class="c1">//   items:</span>
<span class="c1">//    [ Pair {</span>
<span class="c1">//        key: Scalar { value: 'YAML', range: [ 0, 4 ] },</span>
<span class="c1">//        value:</span>
<span class="c1">//         YAMLSeq {</span>
<span class="c1">//           items:</span>
<span class="c1">//            [ Scalar {</span>
<span class="c1">//                value: 'A human-readable data serialization language',</span>
<span class="c1">//                range: [ 10, 55 ] },</span>
<span class="c1">//              Scalar {</span>
<span class="c1">//                value: 'https://en.wikipedia.org/wiki/YAML',</span>
<span class="c1">//                range: [ 59, 94 ] } ],</span>
<span class="c1">//           tag: 'tag:yaml.org,2002:seq',</span>
<span class="c1">//           range: [ 8, 94 ] } },</span>
<span class="c1">//      Pair {</span>
<span class="c1">//        key: Scalar { value: 'yaml', range: [ 94, 98 ] },</span>
<span class="c1">//        value:</span>
<span class="c1">//         YAMLSeq {</span>
<span class="c1">//           items:</span>
<span class="c1">//            [ Scalar {</span>
<span class="c1">//                value: 'A complete JavaScript implementation',</span>
<span class="c1">//                range: [ 104, 141 ] },</span>
<span class="c1">//              Scalar {</span>
<span class="c1">//                value: 'https://www.npmjs.com/package/yaml',</span>
<span class="c1">//                range: [ 145, 180 ] } ],</span>
<span class="c1">//           tag: 'tag:yaml.org,2002:seq',</span>
<span class="c1">//           range: [ 102, 180 ] } } ],</span>
<span class="c1">//   tag: 'tag:yaml.org,2002:map',</span>
<span class="c1">//   range: [ 0, 180 ] }</span>
</code></pre></div><h4 id='yaml-parsedocument-str-options-yaml-document'><code>YAML.parseDocument(str, options = {}): YAML.Document</code></h4>
<p>Parses a single <code>YAML.Document</code> from the input <code>str</code>; used internally by <code>YAML.parse</code>. Will include an error if <code>str</code> contains more than one document. See <a href="#options">Options</a> for more information on the second parameter.</p>

<p><br/></p>
<h4 id='yaml-parsealldocuments-str-options-yaml-document'><code>YAML.parseAllDocuments(str, options = {}): YAML.Document[]</code></h4>
<p>When parsing YAML, the input string <code>str</code> may consist of a stream of documents separated from each other by <code>...</code> document end marker lines. <code>YAML.parseAllDocuments</code> will return an array of <code>Document</code> objects that allow these documents to be parsed and manipulated with more control. See <a href="#options">Options</a> for more information on the second parameter.</p>

<p><br/></p>

<p>These functions should never throw; errors and warnings are included in the documents&#39; <code>errors</code> and <code>warnings</code> arrays. In particular, if <code>errors</code> is not empty it&#39;s likely that the document&#39;s parsed <code>contents</code> are not entirely correct.</p>

<p>The <code>contents</code> of a parsed document will always consist of <code>Scalar</code>, <code>Map</code>, <code>Seq</code> or <code>null</code> values.</p>
<h2 id='creating-documents'>Creating Documents</h2><h4 id='new-yaml-document-value-replacer-options'><code>new YAML.Document(value, replacer?, options = {})</code></h4>
<p>Creates a new document. If <code>value</code> is defined, the document <code>contents</code> are initialised with that value, wrapped recursively in appropriate <a href="#content-nodes">content nodes</a>. If <code>value</code> is <code>undefined</code>, the document&#39;s <code>contents</code> and <code>schema</code> are initialised as <code>null</code>. If defined, a <code>replacer</code> may filter or modify the initial document contents, following the same algorithm as the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">JSON implementation</a>. See <a href="#options">Options</a> for more information on the last argument.</p>

<table><thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>anchors</td>
<td><a href="#anchors"><code>Anchors</code></a></td>
<td>Anchors associated with the document&#39;s nodes; also provides alias &amp; merge node creators.</td>
</tr>
<tr>
<td>commentBefore</td>
<td><code>string?</code></td>
<td>A comment at the very beginning of the document. If not empty, separated from the rest of the document by a blank line or the directives-end indicator when stringified.</td>
</tr>
<tr>
<td>comment</td>
<td><code>string?</code></td>
<td>A comment at the end of the document. If not empty, separated from the rest of the document by a blank line when stringified.</td>
</tr>
<tr>
<td>contents</td>
<td><a href="#content-nodes"><code>Node</code></a>&vert;<code>any</code></td>
<td>The document contents.</td>
</tr>
<tr>
<td>directivesEndMarker</td>
<td><code>boolean?</code></td>
<td>Whether the document should always include a directives-end marker <code>---</code> at its start, even if it includes no directives.</td>
</tr>
<tr>
<td>errors</td>
<td><code>Error[]</code></td>
<td>Errors encountered during parsing.</td>
</tr>
<tr>
<td>schema</td>
<td><code>Schema</code></td>
<td>The schema used with the document.</td>
</tr>
<tr>
<td>tagPrefixes</td>
<td><code>Prefix[]</code></td>
<td>Array of prefixes; each will have a string <code>handle</code> that starts and ends with <code>!</code> and a string <code>prefix</code> that the handle will be replaced by.</td>
</tr>
<tr>
<td>version</td>
<td><code>string?</code></td>
<td>The parsed version of the source document; if true-ish, stringified output will include a <code>%YAML</code> directive.</td>
</tr>
<tr>
<td>warnings</td>
<td><code>Error[]</code></td>
<td>Warnings encountered during parsing.</td>
</tr>
</tbody></table>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">([</span><span class="dl">'</span><span class="s1">some</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">values</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">balloons</span><span class="p">:</span> <span class="mi">99</span> <span class="p">}])</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">version</span> <span class="o">=</span> <span class="kc">true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">commentBefore</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> A commented document</span><span class="dl">'</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// # A commented document</span>
<span class="c1">// %YAML 1.2</span>
<span class="c1">// ---</span>
<span class="c1">// - some</span>
<span class="c1">// - values</span>
<span class="c1">// - balloons: 99</span>
</code></pre></div>
<p>The Document members are all modifiable, though it&#39;s unlikely that you&#39;ll have reason to change <code>errors</code>, <code>schema</code> or <code>warnings</code>. In particular you may be interested in both reading and writing <strong><code>contents</code></strong>. Although <code>YAML.parseDocument()</code> and <code>YAML.parseAllDocuments()</code> will leave it with <code>Map</code>, <code>Seq</code>, <code>Scalar</code> or <code>null</code> contents, it can be set to anything.</p>

<p>During stringification, a document with a true-ish <code>version</code> value will include a <code>%YAML</code> directive; the version number will be set to <code>1.2</code> unless the <code>yaml-1.1</code> schema is in use.</p>
<h2 id='document-methods'>Document Methods</h2>
<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>createNode(value,&nbsp;options?)</td>
<td><code>Node</code></td>
<td>Recursively wrap any input with appropriate <code>Node</code> containers. See <a href="#creating-nodes">Creating Nodes</a> for more information.</td>
</tr>
<tr>
<td>createPair(key,&nbsp;value,&nbsp;options?)</td>
<td><code>Pair</code></td>
<td>Recursively wrap <code>key</code> and <code>value</code> into a <code>Pair</code> object. See <a href="#creating-nodes">Creating Nodes</a> for more information.</td>
</tr>
<tr>
<td>listNonDefaultTags()</td>
<td><code>string[]</code></td>
<td>List the tags used in the document that are not in the default <code>tag:yaml.org,2002:</code> namespace.</td>
</tr>
<tr>
<td>parse(cst)</td>
<td><code>Document</code></td>
<td>Parse a CST into this document. Mostly an internal method, modifying the document according to the contents of the parsed <code>cst</code>. Calling this multiple times on a Document is not recommended.</td>
</tr>
<tr>
<td>setSchema(id?, customTags?)</td>
<td><code>void</code></td>
<td>Set the schema used by the document. <code>id</code> may either be a YAML version, or the identifier of a YAML 1.2 schema; if set, <code>customTags</code> should have the same shape as the similarly-named option.</td>
</tr>
<tr>
<td>setTagPrefix(handle, prefix)</td>
<td><code>void</code></td>
<td>Set <code>handle</code> as a shorthand string for the <code>prefix</code> tag namespace.</td>
</tr>
<tr>
<td>toJS(options?)</td>
<td><code>any</code></td>
<td>A plain JavaScript representation of the document <code>contents</code>.</td>
</tr>
<tr>
<td>toJSON()</td>
<td><code>any</code></td>
<td>A JSON representation of the document <code>contents</code>.</td>
</tr>
<tr>
<td>toString()</td>
<td><code>string</code></td>
<td>A YAML representation of the document.</td>
</tr>
</tbody></table>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">a: 1</span><span class="se">\n</span><span class="s1">b: [2, 3]</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([])</span> <span class="c1">// YAMLMap { items: [Pair, Pair], ... }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">hasIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span> <span class="c1">// -&gt; doc.get('b').items.length === 3</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">deleteIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 4</span>
</code></pre></div>
<p>In addition to the above, the document object also provides the same <strong>accessor methods</strong> as <a href="#collections">collections</a>, based on the top-level collection: <code>add</code>, <code>delete</code>, <code>get</code>, <code>has</code>, and <code>set</code>, along with their deeper variants <code>addIn</code>, <code>deleteIn</code>, <code>getIn</code>, <code>hasIn</code>, and <code>setIn</code>. For the <code>*In</code> methods using an empty <code>path</code> value (i.e. <code>null</code>, <code>undefined</code>, or <code>[]</code>) will refer to the document&#39;s top-level <code>contents</code>.</p>

<p>To define a tag prefix to use when stringifying, use <strong><code>setTagPrefix(handle, prefix)</code></strong> rather than setting a value directly in <code>tagPrefixes</code>. This will guarantee that the <code>handle</code> is valid (by throwing an error), and will overwrite any previous definition for the <code>handle</code>. Use an empty <code>prefix</code> value to remove a prefix.</p>
<h4 id='document-tojs-document-tojson-and-document-tostring'><code>Document#toJS()</code>, <code>Document#toJSON()</code> and <code>Document#toString()</code></h4><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">1969-07-21T02:56:15Z</span><span class="dl">'</span>
<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="p">{</span> <span class="na">customTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">timestamp</span><span class="dl">'</span><span class="p">]</span> <span class="p">})</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span>
<span class="c1">// Date { 1969-07-21T02:56:15.000Z }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJSON</span><span class="p">()</span>
<span class="c1">// '1969-07-21T02:56:15.000Z'</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// '1969-07-21T02:56:15\n'</span>
</code></pre></div>
<p>For a plain JavaScript representation of the document, <strong><code>toJS()</code></strong> is your friend. Its output may include <code>Map</code> and <code>Set</code> collections (e.g. if the <code>mapAsMap</code> option is true) and complex scalar values like <code>Date</code> for <code>!!timestamp</code>, but all YAML nodes will be resolved. For a representation consisting only of JSON values, use <strong><code>toJSON()</code></strong>.</p>

<p>Use <code>toJS({ mapAsMap, onAnchor, reviver })</code> to explicitly set the <code>mapAsMap</code> option, define an <code>onAnchor</code> callback <code>(value: any, count: number) =&gt; void</code> for each aliased anchor in the document, or to apply a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter">reviver function</a> to the output.</p>

<p>Conversely, to stringify a document as YAML, use <strong><code>toString()</code></strong>. This will also be called by <code>String(doc)</code>. This method will throw if the <code>errors</code> array is not empty.</p>
<h2 id='working-with-anchors'>Working with Anchors</h2>
<p>A description of <a href="#alias-nodes">alias and merge nodes</a> is included in the next section.</p>

<p><br/></p>
<h4 id='yaml-document-anchors'><code>YAML.Document#anchors</code></h4>
<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>createAlias(node: Node, name?: string)</td>
<td><code>Alias</code></td>
<td>Create a new <code>Alias</code> node, adding the required anchor for <code>node</code>. If <code>name</code> is empty, a new anchor name will be generated.</td>
</tr>
<tr>
<td>createMergePair(...Node)</td>
<td><code>Merge</code></td>
<td>Create a new <code>Merge</code> node with the given source nodes. Non-<code>Alias</code> sources will be automatically wrapped.</td>
</tr>
<tr>
<td>getName(node: Node)</td>
<td><code>string?</code></td>
<td>The anchor name associated with <code>node</code>, if set.</td>
</tr>
<tr>
<td>getNames()</td>
<td><code>string[]</code></td>
<td>List of all defined anchor names.</td>
</tr>
<tr>
<td>getNode(name: string)</td>
<td><code>Node?</code></td>
<td>The node associated with the anchor <code>name</code>, if set.</td>
</tr>
<tr>
<td>newName(prefix: string)</td>
<td><code>string</code></td>
<td>Find an available anchor name with the given <code>prefix</code> and a numerical suffix.</td>
</tr>
<tr>
<td>setAnchor(node: Node, name?: string)</td>
<td><code>string?</code></td>
<td>Associate an anchor with <code>node</code>. If <code>name</code> is empty, a new name will be generated.</td>
</tr>
</tbody></table>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">[{ a: A }, { b: B }]</span><span class="dl">'</span>
<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">],</span> <span class="kc">true</span><span class="p">))</span> <span class="c1">// 'a1'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">],</span> <span class="kc">true</span><span class="p">))</span> <span class="c1">// 'a2'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">setAnchor</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a1</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'a1'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">getNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">a2</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// { value: 'B', range: [ 16, 18 ], type: 'PLAIN' }</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ { a: A }, { b: &amp;a2 B } ]</span>

<span class="kd">const</span> <span class="nx">alias</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">createAlias</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span> <span class="dl">'</span><span class="s1">AA</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// Alias { source: YAMLMap { items: [ [Pair] ] } }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span>
<span class="c1">// [ { a: 'A' }, { b: 'B' }, { a: 'A' } ]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ &amp;AA { a: A }, { b: &amp;a2 B }, *AA ]</span>

<span class="kd">const</span> <span class="nx">merge</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">createMergePair</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
<span class="c1">// Merge {</span>
<span class="c1">//   key: Scalar { value: '&lt;&lt;' },</span>
<span class="c1">//   value: YAMLSeq { items: [ [Alias] ] } }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="nx">merge</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span>
<span class="c1">// [ { a: 'A' }, { b: 'B', a: 'A' }, { a: 'A' } ]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [ &amp;AA { a: A }, { b: &amp;a2 B, &lt;&lt;: *AA }, *AA ]</span>

<span class="c1">// This creates a circular reference</span>
<span class="nx">merge</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">anchors</span><span class="p">.</span><span class="nx">createAlias</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">)))</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span> <span class="c1">// [RangeError: Maximum call stack size exceeded]</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// [</span>
<span class="c1">//   &amp;AA { a: A },</span>
<span class="c1">//   &amp;a3 {</span>
<span class="c1">//       b: &amp;a2 B,</span>
<span class="c1">//       &lt;&lt;:</span>
<span class="c1">//         [ *AA, *a3 ]</span>
<span class="c1">//     },</span>
<span class="c1">//   *AA</span>
<span class="c1">// ]</span>
</code></pre></div>
<p>The constructors for <code>Alias</code> and <code>Merge</code> are not directly exported by the library, as they depend on the document&#39;s anchors; instead you&#39;ll need to use <strong><code>createAlias(node, name)</code></strong> and <strong><code>createMergePair(...sources)</code></strong>. You should make sure to only add alias and merge nodes to the document after the nodes to which they refer, or the document&#39;s YAML stringification will fail.</p>

<p>It is valid to have an anchor associated with a node even if it has no aliases. <code>yaml</code> will not allow you to associate the same name with more than one node, even though this is allowed by the YAML spec (all but the last instance will have numerical suffixes added). To add or reassign an anchor, use <strong><code>setAnchor(node, name)</code></strong>. The second parameter is optional, and if left out either the pre-existing anchor name of the node will be used, or a new one generated. To remove an anchor, use <code>setAnchor(null, name)</code>. The function will return the new anchor&#39;s name, or <code>null</code> if both of its arguments are <code>null</code>.</p>

<p>While the <code>merge</code> option needs to be true to parse <code>Merge</code> nodes as such, this is not required during stringification.</p>
<h1 id='content-nodes'>Content Nodes</h1>
<p>After parsing, the <code>contents</code> value of each <code>YAML.Document</code> is the root of an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> of nodes representing the document (or <code>null</code> for an empty document).</p>
<h2 id='scalar-values'>Scalar Values</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">comment</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>   <span class="c1">// a comment on or immediately after this</span>
  <span class="nx">commentBefore</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span> <span class="c1">// a comment before this</span>
  <span class="nx">range</span><span class="p">:</span> <span class="p">?[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="p">],</span>
      <span class="c1">// the [start, end] range of characters of the source parsed</span>
      <span class="c1">// into this node (undefined for pairs or if not parsed)</span>
  <span class="nx">spaceBefore</span><span class="p">:</span> <span class="p">?</span><span class="nx">boolean</span><span class="p">,</span>
      <span class="c1">// a blank line before this node and its commentBefore</span>
  <span class="nx">tag</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>       <span class="c1">// a fully qualified tag, if required</span>
  <span class="nx">toJSON</span><span class="p">():</span> <span class="nx">any</span>       <span class="c1">// a plain JS or JSON representation of this node</span>
<span class="p">}</span>
</code></pre></div>
<p>For scalar values, the <code>tag</code> will not be set unless it was explicitly defined in the source document; this also applies for unsupported tags that have been resolved using a fallback tag (string, <code>Map</code>, or <code>Seq</code>).</p>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Scalar</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">format</span><span class="p">:</span> <span class="dl">'</span><span class="s1">BIN</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">HEX</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">OCT</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">TIME</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
      <span class="c1">// By default (undefined), numbers use decimal notation.</span>
      <span class="c1">// The YAML 1.2 core schema only supports 'HEX' and 'OCT'.</span>
  <span class="nx">type</span><span class="p">:</span>
    <span class="dl">'</span><span class="s1">BLOCK_FOLDED</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">BLOCK_LITERAL</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">PLAIN</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">QUOTE_DOUBLE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">any</span>
<span class="p">}</span>
</code></pre></div>
<p>A parsed document&#39;s contents will have all of its non-object values wrapped in <code>Scalar</code> objects, which themselves may be in some hierarchy of <code>Map</code> and <code>Seq</code> collections. However, this is not a requirement for the document&#39;s stringification, which is rather tolerant regarding its input values, and will use <a href="#creating-nodes"><code>doc.createNode()</code></a> when encountering an unwrapped value.</p>

<p>When stringifying, the node <code>type</code> will be taken into account by <code>!!str</code> and <code>!!binary</code> values, and ignored by other scalars. On the other hand, <code>!!int</code> and <code>!!float</code> stringifiers will take <code>format</code> into account.</p>
<h2 id='collections'>Collections</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Pair</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">key</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="p">,</span>    <span class="c1">// key and value are always Node or null</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="p">,</span>  <span class="c1">// when parsed, but can be set to anything</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">PAIR</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nb">Map</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Pair</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FLOW_MAP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">MAP</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Seq</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Node</span> <span class="o">|</span> <span class="nx">any</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FLOW_SEQ</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">SEQ</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span>
<span class="p">}</span>
</code></pre></div>
<p>Within all YAML documents, two forms of collections are supported: sequential <code>Seq</code> collections and key-value <code>Map</code> collections. The JavaScript representations of these collections both have an <code>items</code> array, which may (<code>Seq</code>) or must (<code>Map</code>) consist of <code>Pair</code> objects that contain a <code>key</code> and a <code>value</code> of any type, including <code>null</code>. The <code>items</code> array of a <code>Seq</code> object may contain values of any type.</p>

<p>When stringifying collections, by default block notation will be used. Flow notation will be selected if <code>type</code> is <code>FLOW_MAP</code> or <code>FLOW_SEQ</code>, the collection is within a surrounding flow collection, or if the collection is in an implicit key.</p>

<p>The <code>yaml-1.1</code> schema includes <a href="https://yaml.org/type/index.html">additional collections</a> that are based on <code>Map</code> and <code>Seq</code>: <code>OMap</code> and <code>Pairs</code> are sequences of <code>Pair</code> objects (<code>OMap</code> requires unique keys &amp; corresponds to the JS Map object), and <code>Set</code> is a map of keys with null values that corresponds to the JS Set object.</p>

<p>All of the collections provide the following accessor methods:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>add(value), addIn(path, value)</td>
<td><code>void</code></td>
<td>Adds a value to the collection. For <code>!!map</code> and <code>!!omap</code> the value must be a Pair instance or a <code>{ key, value }</code> object, which may not have a key that already exists in the map.</td>
</tr>
<tr>
<td>delete(key), deleteIn(path)</td>
<td><code>boolean</code></td>
<td>Removes a value from the collection. Returns <code>true</code> if the item was found and removed.</td>
</tr>
<tr>
<td>get(key,&nbsp;[keep]), getIn(path,&nbsp;[keep])</td>
<td><code>any</code></td>
<td>Returns value at <code>key</code>, or <code>undefined</code> if not found. By default unwraps scalar values from their surrounding node; to disable set <code>keep</code> to <code>true</code> (collections are always returned intact).</td>
</tr>
<tr>
<td>has(key), hasIn(path)</td>
<td><code>boolean</code></td>
<td>Checks if the collection includes a value with the key <code>key</code>.</td>
</tr>
<tr>
<td>set(key, value), setIn(path, value)</td>
<td><code>any</code></td>
<td>Sets a value in this collection. For <code>!!set</code>, <code>value</code> needs to be a boolean to add/remove the item from the set. When overwriting a <code>Scalar</code> value with a scalar, the original node is retained.</td>
</tr>
</tbody></table>

<!-- prettier-ignore -->
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">})</span> <span class="c1">// { a: 1, b: [ 2, 3 ] }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span> <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="mi">4</span> <span class="p">})</span> <span class="c1">// { a: 1, b: [ 2, 3 ], c: 4 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>             <span class="c1">// { a: 1, b: [ 2, 3, 5 ], c: 4 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>                <span class="c1">// { a: 1, b: [ 2, 3, 5 ], c: 42 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">setIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">])</span> <span class="c1">// Error: Expected YAML collection at c. Remaining path: x</span>
<span class="nx">doc</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span>                 <span class="c1">// { a: 1, b: [ 2, 3, 5 ] }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">deleteIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>          <span class="c1">// { a: 1, b: [ 2, 5 ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Scalar { value: 1 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 5</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">createNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">hasIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">])</span> <span class="c1">// true</span>
</code></pre></div>
<p>For all of these methods, the keys may be nodes or their wrapped scalar values (i.e. <code>42</code> will match <code>Scalar { value: 42 }</code>) . Keys for <code>!!seq</code> should be positive integers, or their string representations. <code>add()</code> and <code>set()</code> do not automatically call <code>doc.createNode()</code> to wrap the value.</p>

<p>Each of the methods also has a variant that requires an iterable as the first parameter, and allows fetching or modifying deeper collections. If any intermediate node in <code>path</code> is a scalar rather than a collection, an error will be thrown. If any of the intermediate collections is not found:</p>

<ul>
<li><code>getIn</code> and <code>hasIn</code> will return <code>undefined</code> or <code>false</code> (respectively)</li>
<li><code>addIn</code> and <code>setIn</code> will create missing collections; non-negative integer keys will create sequences, all other keys create maps</li>
<li><code>deleteIn</code> will throw an error</li>
</ul>

<p>Note that for <code>addIn</code> the path argument points to the collection rather than the item; for maps its <code>value</code> should be a <code>Pair</code> or an object with <code>{ key, value }</code> fields.</p>
<h2 id='alias-nodes'>Alias Nodes</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Alias</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">source</span><span class="p">:</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nb">Map</span> <span class="o">|</span> <span class="nx">Seq</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ALIAS</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ &amp;x { X: 42 }, Y, *x ]</span><span class="dl">'</span><span class="p">)</span>
  <span class="c1">// =&gt; [ { X: 42 }, 'Y', { X: 42 } ]</span>
<span class="nx">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">Z</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="c1">// =&gt; [ { X: 42, Z: 13 }, 'Y', { X: 42, Z: 13 } ]</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
  <span class="c1">// - &amp;a1</span>
  <span class="c1">//   X: 42</span>
  <span class="c1">//   Z: 13</span>
  <span class="c1">// - Y</span>
  <span class="c1">// - *a1</span>
</code></pre></div>
<p><code>Alias</code> nodes provide a way to include a single node in multiple places in a document; the <code>source</code> of an alias node must be a preceding node in the document. Circular references are fully supported, and where possible the JS representation of alias nodes will be the actual source object.</p>

<p>When nodes are constructed from JS structures (e.g. during <code>YAML.stringify()</code>), multiple references to the same object will result in including an autogenerated anchor at its first instance, and alias nodes to that anchor at later references.</p>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Merge</span> <span class="kd">extends</span> <span class="nx">Pair</span> <span class="p">{</span>
  <span class="nl">key</span><span class="p">:</span> <span class="nx">Scalar</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;&lt;</span><span class="dl">'</span><span class="p">),</span>      <span class="c1">// defined by the type specification</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">Seq</span><span class="o">&lt;</span><span class="nx">Alias</span><span class="p">(</span><span class="nb">Map</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="c1">// stringified as *A if length = 1</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MERGE_PAIR</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Merge</code> nodes are not a core YAML 1.2 feature, but are defined as a <a href="http://yaml.org/type/merge.html">YAML 1.1 type</a>. They are only valid directly within a <code>Map#items</code> array and must contain one or more <code>Alias</code> nodes that themselves refer to <code>Map</code> nodes. When the surrounding map is resolved as a plain JS object, the key-value pairs of the aliased maps will be included in the object. Earlier <code>Alias</code> nodes override later ones, as do values set in the object directly.</p>

<p>To create and work with alias and merge nodes, you should use the <a href="#working-with-anchors"><code>YAML.Document#anchors</code></a> object.</p>
<h2 id='creating-nodes'>Creating Nodes</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">([</span><span class="dl">'</span><span class="s1">some</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">values</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// Document {</span>
<span class="c1">//   contents:</span>
<span class="c1">//     YAMLSeq {</span>
<span class="c1">//       items:</span>
<span class="c1">//        [ Scalar { value: 'some' },</span>
<span class="c1">//          Scalar { value: 'values' } ] } }</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">createNode</span><span class="p">({</span> <span class="na">balloons</span><span class="p">:</span> <span class="mi">99</span> <span class="p">})</span>
<span class="c1">// YAMLMap {</span>
<span class="c1">//   items:</span>
<span class="c1">//    [ Pair {</span>
<span class="c1">//        key: Scalar { value: 'balloons' },</span>
<span class="c1">//        value: Scalar { value: 99 } } ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> A commented item</span><span class="dl">'</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// - some # A commented item</span>
<span class="c1">// - values</span>
<span class="c1">// - balloons: 99</span>
</code></pre></div><h4 id='yaml-document-createnode-value-options-node'><code>YAML.Document#createNode(value, options?): Node</code></h4>
<p>To create a new node, use the <code>createNode(value, options?)</code> document method. This will recursively wrap any input with appropriate <code>Node</code> containers. Generic JS <code>Object</code> values as well as <code>Map</code> and its descendants become mappings, while arrays and other iterable objects result in sequences. With <code>Object</code>, entries that have an <code>undefined</code> value are dropped.</p>

<p>Use <code>options.replacer</code> to apply a replacer array or function, following the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">JSON implementation</a>. To specify the collection type, set <code>options.tag</code> to its identifying string, e.g. <code>&quot;!!omap&quot;</code>. Note that this requires the corresponding tag to be available in the document&#39;s schema. If <code>options.wrapScalars</code> is undefined or <code>true</code>, plain values are wrapped in <code>Scalar</code> objects.</p>

<p>As a possible side effect, this method may add entries to the document&#39;s <a href="#working-with-anchors"><code>anchors</code></a></p>

<p>The primary purpose of this method is to enable attaching comments or other metadata to a value, or to otherwise exert more fine-grained control over the stringified output. To that end, you&#39;ll need to assign its return value to the <code>contents</code> of a document (or somewhere within said contents), as the document&#39;s schema is required for YAML string output. If you&#39;re not interested in working with such metadata, document <code>contents</code> may also include non-<code>Node</code> values at any level.</p>

<h4 style="clear:both"><code>new YAMLMap(), new YAMLSeq(), doc.createPair(key, value)</code></h4>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">YAML</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">YAMLSeq</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/types</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">(</span><span class="k">new</span> <span class="nx">YAMLSeq</span><span class="p">())</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
  <span class="dl">'</span><span class="s1">some values</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">42</span><span class="p">,</span>
  <span class="p">{</span> <span class="na">including</span><span class="p">:</span> <span class="dl">'</span><span class="s1">objects</span><span class="dl">'</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a string</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">]</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">createPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a number</span><span class="dl">'</span><span class="p">))</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// - some values</span>
<span class="c1">// - 42</span>
<span class="c1">// - "3": a string</span>
<span class="c1">//   including: objects</span>
<span class="c1">// - 1: a number</span>
</code></pre></div>
<p>To construct a <code>YAMLSeq</code> or <code>YAMLMap</code>, use <code>doc.createNode()</code> with array, object or iterable input, or create the collections directly by importing the classes from <code>yaml/types</code>.</p>

<p>Once created, normal array operations may be used to modify the <code>items</code> array. New <code>Pair</code> objects may created either by importing the class from <code>yaml/types</code> and using its <code>new Pair(key, value)</code> constructor, or by using the <code>doc.createPair(key, value, options?)</code> method. The latter will recursively wrap the <code>key</code> and <code>value</code> as nodes, and accepts the same options as <code>doc.createNode()</code></p>
<h2 id='comments'>Comments</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s2">`
# This is YAML.
---
it has:
  - an array
  - of values
`</span><span class="p">)</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span>
<span class="c1">// { 'it has': [ 'an array', 'of values' ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">commentBefore</span>
<span class="c1">// ' This is YAML.'</span>

<span class="kd">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> item comment</span><span class="dl">'</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> collection end comment</span><span class="dl">'</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// # This is YAML.</span>
<span class="c1">//</span>
<span class="c1">// it has:</span>
<span class="c1">//   - an array # item comment</span>
<span class="c1">//   - of values</span>
<span class="c1">//   # collection end comment</span>
</code></pre></div>
<p>A primary differentiator between this and other YAML libraries is the ability to programmatically handle comments, which according to <a href="http://yaml.org/spec/1.2/spec.html#id2767100">the spec</a> &quot;must not have any effect on the serialization tree or representation graph. In particular, comments are not associated with a particular node.&quot;</p>

<p>This library does allow comments to be handled programmatically, and does attach them to particular nodes (most often, the following node). Each <code>Scalar</code>, <code>Map</code>, <code>Seq</code> and the <code>Document</code> itself has <code>comment</code> and <code>commentBefore</code> members that may be set to a stringifiable value.</p>

<p>The string contents of comments are not processed by the library, except for merging adjacent comment lines together and prefixing each line with the <code>#</code> comment indicator. Document comments will be separated from the rest of the document by a blank line.</p>

<p><strong>Note</strong>: Due to implementation details, the library&#39;s comment handling is not completely stable. In particular, when creating, writing, and then reading a YAML file, comments may sometimes be associated with a different node.</p>
<h2 id='blank-lines'>Blank Lines</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ one, two, three ]</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> item comment</span><span class="dl">'</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">spaceBefore</span> <span class="o">=</span> <span class="kc">true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> document end comment</span><span class="dl">'</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// [</span>
<span class="c1">//   one, # item comment</span>
<span class="c1">//</span>
<span class="c1">//   two,</span>
<span class="c1">//   three</span>
<span class="c1">// ]</span>
<span class="c1">//</span>
<span class="c1">// # document end comment</span>
</code></pre></div>
<p>Similarly to comments, the YAML spec instructs non-content blank lines to be discarded. Instead of doing that, <code>yaml</code> provides a <code>spaceBefore</code> boolean property for each node. If true, the node (and its <code>commentBefore</code>, if any) will be separated from the preceding node by a blank line.</p>

<p>Note that scalar block values with &quot;keep&quot; chomping (i.e. with <code>+</code> in their header) consider any trailing empty lines to be a part of their content, so the <code>spaceBefore</code> setting of a node following such a value is ignored.</p>
<h1 id='custom-data-types'>Custom Data Types</h1><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">!!timestamp 2001-12-15 2:59:43</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:yaml.org,2002:timestamp is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:str</span>
<span class="c1">// '2001-12-15 2:59:43'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">customTags</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">timestamp</span><span class="dl">'</span><span class="p">]</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">2001-12-15 2:59:43</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// returns a Date instance</span>
<span class="c1">// 2001-12-15T02:59:43.000Z</span>

<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="dl">'</span><span class="s1">2001-12-15 2:59:43</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">value</span><span class="p">.</span><span class="nx">toDateString</span><span class="p">()</span>
<span class="c1">// 'Sat Dec 15 2001'</span>
</code></pre></div>
<p>The easiest way to extend a <a href="#data-schemas">schema</a> is by defining the additional <strong>tags</strong> that you wish to support. To do that, the <code>customTags</code> option allows you to provide an array of custom tag objects or tag identifiers. In particular, the built-in tags that are a part of the <code>core</code> and <code>yaml-1.1</code> schemas may be referred to by their string identifiers. For those tags that are available in both, only the <code>core</code> variant is provided as a custom tag.</p>

<p>For further customisation, <code>customTags</code> may also be a function <code>(Tag[]) =&gt; (Tag[])</code> that may modify the schema&#39;s base tag array.</p>
<h2 id='built-in-custom-tags'>Built-in Custom Tags</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ one, true, 42 ]</span><span class="dl">'</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">v</span><span class="p">)</span>
<span class="c1">// [ 'string', 'boolean', 'number' ]</span>

<span class="kd">let</span> <span class="nx">opt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failsafe</span><span class="dl">'</span> <span class="p">}</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ one, true, 42 ]</span><span class="dl">'</span><span class="p">,</span> <span class="nx">opt</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">v</span><span class="p">)</span>
<span class="c1">// [ 'string', 'string', 'string' ]</span>

<span class="nx">opt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failsafe</span><span class="dl">'</span><span class="p">,</span> <span class="na">customTags</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">int</span><span class="dl">'</span><span class="p">]</span> <span class="p">}</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ one, true, 42 ]</span><span class="dl">'</span><span class="p">,</span> <span class="nx">opt</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">v</span><span class="p">)</span>
<span class="c1">// [ 'string', 'string', 'number' ]</span>
</code></pre></div><h3 id='yaml-1-2-core-schema'>YAML 1.2 Core Schema</h3>
<p>These tags are a part of the YAML 1.2 <a href="https://yaml.org/spec/1.2/spec.html#id2804923">Core Schema</a>, and may be useful when constructing a parser or stringifier for a more limited set of types, based on the <code>failsafe</code> schema. Some of these define a <code>format</code> value; this will be added to the parsed nodes and affects the node&#39;s stringification.</p>

<p>If including more than one custom tag from this set, make sure that the <code>&#39;float&#39;</code> and <code>&#39;int&#39;</code> tags precede any of the other <code>!!float</code> and <code>!!int</code> tags.</p>

<table><thead>
<tr>
<th>Identifier</th>
<th>Regular expression</th>
<th>YAML Type</th>
<th>Format</th>
<th>Example values</th>
</tr>
</thead><tbody>
<tr>
<td><code>&#39;bool&#39;</code></td>
<td><code>true⎮True⎮TRUE⎮false⎮False⎮FALSE</code></td>
<td><code>!!bool</code></td>
<td></td>
<td><code>true</code>, <code>false</code></td>
</tr>
<tr>
<td><code>&#39;float&#39;</code></td>
<td><code>[-+]?(0⎮[1-9][0-9]*)\.[0-9]*</code></td>
<td><code>!!float</code></td>
<td></td>
<td><code>4.2</code>, <code>-0.0</code></td>
</tr>
<tr>
<td><code>&#39;floatExp&#39;</code></td>
<td><code>[-+]?(0⎮[1-9][0-9]*)(\.[0-9]*)?[eE][-+]?[0-9]+</code></td>
<td><code>!!float</code></td>
<td><code>&#39;EXP&#39;</code></td>
<td><code>4.2e9</code></td>
</tr>
<tr>
<td><code>&#39;floatNaN&#39;</code></td>
<td><code>[-+]?(\.inf⎮\.Inf⎮\.INF)⎮\.nan⎮\.NaN⎮\.NAN</code></td>
<td><code>!!float</code></td>
<td></td>
<td><code>-Infinity</code></td>
</tr>
<tr>
<td><code>&#39;int&#39;</code></td>
<td><code>[-+]?[0-9]+</code></td>
<td><code>!!int</code></td>
<td></td>
<td><code>42</code>, <code>-0</code></td>
</tr>
<tr>
<td><code>&#39;intHex&#39;</code></td>
<td><code>0x[0-9a-fA-F]+</code></td>
<td><code>!!int</code></td>
<td><code>&#39;HEX&#39;</code></td>
<td><code>0xff0033</code></td>
</tr>
<tr>
<td><code>&#39;intOct&#39;</code></td>
<td><code>0o[0-7]+</code></td>
<td><code>!!int</code></td>
<td><code>&#39;OCT&#39;</code></td>
<td><code>0o127</code></td>
</tr>
<tr>
<td><code>&#39;null&#39;</code></td>
<td><code>~⎮null⎮Null⎮NULL</code></td>
<td><code>!!null</code></td>
<td></td>
<td><code>null</code></td>
</tr>
</tbody></table>
<h3 id='yaml-1-1'>YAML 1.1</h3>
<p>These tags are a part of the YAML 1.1 <a href="https://yaml.org/type/">language-independent types</a>, but are not a part of any default YAML 1.2 schema.</p>

<table><thead>
<tr>
<th>Identifier</th>
<th>YAML Type</th>
<th>JS Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td><code>&#39;binary&#39;</code></td>
<td><a href="https://yaml.org/type/binary.html"><code>!!binary</code></a></td>
<td><code>Uint8Array</code></td>
<td>Binary data, represented in YAML as base64 encoded characters.</td>
</tr>
<tr>
<td><code>&#39;floatTime&#39;</code></td>
<td><a href="https://yaml.org/type/float.html"><code>!!float</code></a></td>
<td><code>Number</code></td>
<td>Sexagesimal floating-point number format, e.g. <code>190:20:30.15</code>. To stringify with this tag, the node <code>format</code> must be <code>&#39;TIME&#39;</code>.</td>
</tr>
<tr>
<td><code>&#39;intTime&#39;</code></td>
<td><a href="https://yaml.org/type/int.html"><code>!!int</code></a></td>
<td><code>Number</code></td>
<td>Sexagesimal integer number format, e.g. <code>190:20:30</code>. To stringify with this tag, the node <code>format</code> must be <code>&#39;TIME&#39;</code>.</td>
</tr>
<tr>
<td><code>&#39;omap&#39;</code></td>
<td><a href="https://yaml.org/type/omap.html"><code>!!omap</code></a></td>
<td><code>Map</code></td>
<td>Ordered sequence of key: value pairs without duplicates. Using <code>mapAsMap: true</code> together with this tag is not recommended, as it makes the parse → stringify loop non-idempotent.</td>
</tr>
<tr>
<td><code>&#39;pairs&#39;</code></td>
<td><a href="https://yaml.org/type/pairs.html"><code>!!pairs</code></a></td>
<td><code>Array</code></td>
<td>Ordered sequence of key: value pairs allowing duplicates. To create from JS, use <code>doc.createNode(array, { tag: &#39;!!pairs&#39; })</code>.</td>
</tr>
<tr>
<td><code>&#39;set&#39;</code></td>
<td><a href="https://yaml.org/type/set.html"><code>!!set</code></a></td>
<td><code>Set</code></td>
<td>Unordered set of non-equal values.</td>
</tr>
<tr>
<td><code>&#39;timestamp&#39;</code></td>
<td><a href="https://yaml.org/type/timestamp.html"><code>!!timestamp</code></a></td>
<td><code>Date</code></td>
<td>A point in time, e.g. <code>2001-12-15T02:59:43</code>.</td>
</tr>
</tbody></table>
<h2 id='writing-custom-tags'>Writing Custom Tags</h2><div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">stringifyString</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/util</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">regexp</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">identify</span><span class="p">:</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="k">instanceof</span> <span class="nb">RegExp</span><span class="p">,</span>
  <span class="na">tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">!re</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">cst</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">match</span> <span class="o">=</span> <span class="nx">cst</span><span class="p">.</span><span class="nx">strValue</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">\/([\s\S]</span><span class="sr">+</span><span class="se">)\/([</span><span class="sr">gimuy</span><span class="se">]</span><span class="sr">*</span><span class="se">)</span><span class="sr">$/</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">sharedSymbol</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">identify</span><span class="p">:</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span><span class="p">.</span><span class="kd">constructor</span> <span class="o">===</span> <span class="nb">Symbol</span><span class="p">,</span>
  <span class="na">tag</span><span class="p">:</span> <span class="dl">'</span><span class="s1">!symbol/shared</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">resolve</span><span class="p">:</span> <span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="nx">cst</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="nx">cst</span><span class="p">.</span><span class="nx">strValue</span><span class="p">),</span>
  <span class="nx">stringify</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">onComment</span><span class="p">,</span> <span class="nx">onChompKeep</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">Only shared symbols are supported</span><span class="dl">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">stringifyString</span><span class="p">({</span> <span class="na">value</span><span class="p">:</span> <span class="nx">key</span> <span class="p">},</span> <span class="nx">ctx</span><span class="p">,</span> <span class="nx">onComment</span><span class="p">,</span> <span class="nx">onChompKeep</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">defaultOptions</span><span class="p">.</span><span class="nx">customTags</span> <span class="o">=</span> <span class="p">[</span><span class="nx">regexp</span><span class="p">,</span> <span class="nx">sharedSymbol</span><span class="p">]</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
  <span class="na">regexp</span><span class="p">:</span> <span class="sr">/foo/gi</span><span class="p">,</span>
  <span class="na">symbol</span><span class="p">:</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">bar</span><span class="dl">'</span><span class="p">)</span>
<span class="p">})</span>
<span class="c1">// regexp: !re /foo/gi</span>
<span class="c1">// symbol: !symbol/shared bar</span>
</code></pre></div>
<p>In YAML-speak, a custom data type is represented by a <em>tag</em>. To define your own tag, you need to account for the ways that your data is both parsed and stringified. Furthermore, both of those processes are split into two stages by the intermediate AST node structure.</p>

<p>If you wish to implement your own custom tags, the <a href="https://github.com/eemeli/yaml/blob/master/src/tags/yaml-1.1/binary.js"><code>!!binary</code></a> and <a href="https://github.com/eemeli/yaml/blob/master/src/tags/yaml-1.1/set.js"><code>!!set</code></a> tags provide relatively cohesive examples to study in addition to the simple examples in the sidebar here.</p>
<h3 id='parsing-custom-data'>Parsing Custom Data</h3>
<p>At the lowest level, <a href="#cst-parser"><code>YAML.parseCST()</code></a> will take care of turning string input into a concrete syntax tree (CST). In the CST all scalar values are available as strings, and maps &amp; sequences as collections of nodes. Each schema includes a set of default data types, which handle converting at least strings, maps and sequences into their AST nodes. These are considered to have <em>implicit</em> tags, and are autodetected. Custom tags, on the other hand, should almost always define an <em>explicit</em> <code>tag</code> with which their value will be prefixed. This may be application-specific local <code>!tag</code>, a shorthand <code>!ns!tag</code>, or a verbatim <code>!&lt;tag:example.com,2019:tag&gt;</code>.</p>

<p>Once identified by matching the <code>tag</code>, the <code>resolve(value, onError): Node | any</code> function will turn a parsed value into an AST node. <code>value</code> may be either a <code>string</code>, a <code>YAMLMap</code> or a <code>YAMLSeq</code>, depending on the node&#39;s shape. A custom tag should verify that value is of its expected type.</p>

<p>Note that during the CST -&gt; AST parsing, the anchors and comments attached to each node are also resolved for each node. This metadata will unfortunately be lost when converting the values to JS objects, so collections should have values that extend one of the existing collection classes. Collections should therefore either fall back to their parent classes&#39; <code>toJSON()</code> methods, or define their own in order to allow their contents to be expressed as the appropriate JS object.</p>
<h3 id='creating-nodes-and-stringifying-custom-data'>Creating Nodes and Stringifying Custom Data</h3>
<p>As with parsing, turning input data into its YAML string representation is a two-stage process as the input is first turned into an AST tree before stringifying it. This allows for metadata and comments to be attached to each node, and for e.g. circular references to be resolved. For scalar values, this means just wrapping the value within a <code>Scalar</code> class while keeping it unchanged.</p>

<p>As values may be wrapped within objects and arrays, <code>doc.createNode()</code> uses each tag&#39;s <code>identify(value): boolean</code> function to detect custom data types. For the same reason, collections need to define their own <code>createNode(schema, value, ctx): Collection</code> functions that may recursively construct their equivalent collection class instances.</p>

<p>Finally, <code>stringify(item, ctx, ...): string</code> defines how your data should be represented as a YAML string, in case the default stringifiers aren&#39;t enough. For collections in particular, the default stringifier should be perfectly sufficient. <code>&#39;yaml/util&#39;</code> exports <code>stringifyNumber(item)</code> and <code>stringifyString(item, ctx, ...)</code>, which may be of use for custom scalar data.</p>
<h3 id='custom-tag-api'>Custom Tag API</h3>
<!-- prettier-ignore -->
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span>
  <span class="nx">findPair</span><span class="p">,</span> <span class="c1">// (items, key) =&gt; Pair? -- Given a key, find a matching Pair</span>
  <span class="nx">stringifyNumber</span><span class="p">,</span> <span class="c1">// (node) =&gt; string</span>
  <span class="nx">stringifyString</span><span class="p">,</span> <span class="c1">// (node, ctx, ...) =&gt; string</span>
  <span class="nx">toJS</span><span class="p">,</span> <span class="c1">// (value, arg, ctx) =&gt; any -- Recursively convert to plain JS</span>
  <span class="nx">Type</span><span class="p">,</span> <span class="c1">// { [string]: string } -- Used as enum for node types</span>
  <span class="nx">YAMLReferenceError</span><span class="p">,</span> <span class="nx">YAMLSemanticError</span><span class="p">,</span> <span class="nx">YAMLSyntaxError</span><span class="p">,</span> <span class="nx">YAMLWarning</span>
<span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/util</span><span class="dl">'</span>
</code></pre></div>
<p>To define your own tag, you&#39;ll need to define an object comprising of some of the following fields. Those in bold are required:</p>

<ul>
<li><code>createNode(schema, value, ctx): Node</code> is an optional factory function, used e.g. by collections when wrapping JS objects as AST nodes.</li>
<li><code>format: string</code> If a tag has multiple forms that should be parsed and/or stringified differently, use <code>format</code> to identify them. Used by <code>!!int</code> and <code>!!float</code>.</li>
<li><strong><code>identify(value): boolean</code></strong> is used by <code>doc.createNode()</code> to detect your data type, e.g. using <code>typeof</code> or <code>instanceof</code>. Required.</li>
<li><code>nodeClass: Node</code> is the <code>Node</code> child class that implements this tag. Required for collections and tags that have overlapping JS representations.</li>
<li><code>options: Object</code> is used by some tags to configure their stringification.</li>
<li><strong><code>resolve(value, onError): Node | any</code></strong> turns a parsed value into an AST node; <code>value</code> is either a <code>string</code>, a <code>YAMLMap</code> or a <code>YAMLSeq</code>. <code>onError(msg)</code> should be called with an error message string when encountering errors, as it&#39;ll allow you to still return some value for the node. If returning a non-<code>Node</code> value, the output will be wrapped as a <code>Scalar</code>. Required.</li>
<li><code>stringify(item, ctx, onComment, onChompKeep): string</code> is an optional function stringifying the <code>item</code> AST node in the current context <code>ctx</code>. <code>onComment</code> and <code>onChompKeep</code> are callback functions for a couple of special cases. If your data includes a suitable <code>.toString()</code> method, you can probably leave this undefined and use the default stringifier.</li>
<li><strong><code>tag: string</code></strong> is the identifier for your data type, with which its stringified form will be prefixed. Should either be a !-prefixed local <code>!tag</code>, or a fully qualified <code>tag:domain,date:foo</code>. Required.</li>
<li><code>test: RegExp</code> and <code>default: boolean</code> allow for values to be stringified without an explicit tag and detected using a regular expression. For most cases, it&#39;s unlikely that you&#39;ll actually want to use these, even if you first think you do.</li>
</ul>
<h1 id='cst-parser'>CST Parser</h1>
<p>For ease of implementation and to provide better error handling and reporting, the lowest level of the library&#39;s parser turns any input string into a <a href="https://en.wikipedia.org/wiki/Concrete_syntax_tree"><strong>Concrete Syntax Tree</strong></a> of nodes as if the input were YAML. This level of the API has not been designed to be particularly user-friendly for external users, but it is fast, robust, and not dependent on the rest of the library.</p>
<h2 id='parsecst'>parseCST</h2>
<!-- prettier-ignore -->
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">parseCST</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/parse-cst</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">parseCST</span><span class="p">(</span><span class="s2">`
sequence: [ one, two, ]
mapping: { sky: blue, sea: green }
---
-
  "flow in block"
- &gt;
 Block scalar
- !!map # Block collection
  foo : bar
`</span><span class="p">)</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>            <span class="c1">// first document, containing a map with two keys</span>
  <span class="p">.</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">// document contents (as opposed to directives)</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">3</span><span class="p">].</span><span class="nx">node</span>  <span class="c1">// the last item, a flow map</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>       <span class="c1">// the fourth token, parsed as a plain value</span>
  <span class="p">.</span><span class="nx">strValue</span>       <span class="c1">// 'blue'</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>            <span class="c1">// second document, containing a sequence</span>
  <span class="p">.</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>    <span class="c1">// document contents (as opposed to directives)</span>
  <span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">node</span>  <span class="c1">// the second item, a block value</span>
  <span class="p">.</span><span class="nx">strValue</span>       <span class="c1">// 'Block scalar\n'</span>
</code></pre></div><h4 id='parsecst-string-cstdocument'><code>parseCST(string): CSTDocument[]</code></h4><h4 id='yaml-parsecst-string-cstdocument'><code>YAML.parseCST(string): CSTDocument[]</code></h4>
<p>The CST parser will not produce a CST that is necessarily valid YAML, and in particular its representation of collections of items is expected to undergo further processing and validation. The parser should never throw errors, but may include them as a value of the relevant node. On the other hand, if you feed it garbage, you&#39;ll likely get a garbage CST as well.</p>

<p>The public API of the CST layer is a single function which returns an array of parsed CST documents. The array and its contained nodes override the default <code>toString</code> method, each returning a YAML string representation of its contents. The same function is exported as a part of the default <code>YAML</code> object, as well as seprately at <code>yaml/parse-cst</code>. It has no dependency on the rest of the library, so importing only <code>parseCST</code> should add about 9kB to your gzipped bundle size, when the whole library will add about 27kB.</p>

<p>Care should be taken when modifying the CST, as no error checks are included to verify that the resulting YAML is valid, or that e.g. indentation levels aren&#39;t broken. In other words, this is an engineering tool and you may hurt yourself. If you&#39;re looking to generate a brand new YAML document, see the section on <a href="#creating-documents">Creating Documents</a>.</p>

<p>For more usage examples and CST trees, have a look through the <a href="https://github.com/eemeli/yaml/tree/master/tests/cst">extensive test suite</a> included in the project&#39;s repository.</p>

<h3 style="clear:both">Error detection</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">YAML</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseCST</span><span class="p">(</span><span class="dl">'</span><span class="s1">this: is: bad YAML</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// Note: Simplified for clarity</span>
<span class="c1">// { type: 'MAP',</span>
<span class="c1">//   items: [</span>
<span class="c1">//     { type: 'PLAIN', strValue: 'this' },</span>
<span class="c1">//     { type: 'MAP_VALUE',</span>
<span class="c1">//       node: {</span>
<span class="c1">//         type: 'MAP',</span>
<span class="c1">//         items: [</span>
<span class="c1">//           { type: 'PLAIN', strValue: 'is' },</span>
<span class="c1">//           { type: 'MAP_VALUE',</span>
<span class="c1">//             node: { type: 'PLAIN', strValue: 'bad YAML' } } ] } } ] }</span>

<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">()</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">errors</span>
<span class="c1">// [ {</span>
<span class="c1">//   name: 'YAMLSemanticError',</span>
<span class="c1">//   message: 'Nested mappings are not allowed in compact mappings',</span>
<span class="c1">//   source: {</span>
<span class="c1">//     type: 'MAP',</span>
<span class="c1">//     range: { start: 6, end: 18 },</span>
<span class="c1">//     ...,</span>
<span class="c1">//     rawValue: 'is: bad YAML' } } ]</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">.</span><span class="nx">value</span>
<span class="c1">// 'bad YAML'</span>
</code></pre></div>
<p>While the YAML spec considers e.g. block collections within a flow collection to be an error, this error will not be detected by the CST parser. For complete validation, you will need to parse the CST into a <code>YAML.Document</code>. If the document contains errors, they will be included in the document&#39;s <code>errors</code> array, and each error will will contain a <code>source</code> reference to the CST node where it was encountered. Do note that even if an error is encountered, the document contents might still be available. In such a case, the error will be a <a href="#yamlsemanticerror"><code>YAMLSemanticError</code></a> rather than a <a href="#yamlsyntaxerror"><code>YAMLSyntaxError</code></a>.</p>

<h3 style="clear:both">Dealing with CRLF line terminators</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="nx">parseCST</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml/parse-cst</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">- foo</span><span class="se">\r\n</span><span class="s1">- bar</span><span class="se">\r\n</span><span class="dl">'</span>
<span class="kd">const</span> <span class="nx">cst</span> <span class="o">=</span> <span class="nx">parseCST</span><span class="p">(</span><span class="nx">src</span><span class="p">)</span>
<span class="nx">cst</span><span class="p">.</span><span class="nx">setOrigRanges</span><span class="p">()</span> <span class="c1">// true</span>
<span class="kd">const</span> <span class="p">{</span> <span class="nx">range</span><span class="p">,</span> <span class="nx">valueRange</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">cst</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">items</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">node</span>

<span class="nx">src</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">range</span><span class="p">.</span><span class="nx">origStart</span><span class="p">,</span> <span class="nx">range</span><span class="p">.</span><span class="nx">origEnd</span><span class="p">)</span>
<span class="c1">// 'bar\r\n'</span>

<span class="nx">src</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">valueRange</span><span class="p">.</span><span class="nx">origStart</span><span class="p">,</span> <span class="nx">valueRange</span><span class="p">.</span><span class="nx">origEnd</span><span class="p">)</span>
<span class="c1">// 'bar'</span>
</code></pre></div><h4 id='cst-setorigranges-bool'><code>CST#setOrigRanges(): bool</code></h4>
<p>The array returned by <code>parseCST()</code> will also include a method <code>setOrigRanges</code> to help deal with input that includes <code>\r\n</code> line terminators, which are converted to just <code>\n</code> before parsing into documents. This conversion will obviously change the total length of the string, as well as the offsets of all ranges. If the method returns <code>false</code>, the input did not include <code>\r\n</code> line terminators and no changes were made. However, if the method returns <code>true</code>, each <code>Range</code> object within the CST will have its <code>origStart</code> and <code>origEnd</code> values set appropriately to refer to the original input string.</p>
<h2 id='cst-nodes'>CST Nodes</h2>
<blockquote>
<p>Node type definitions use Flow-ish notation, so <code>+</code> as a prefix indicates a read-only getter property.</p>
</blockquote>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Range</span> <span class="p">{</span>
  <span class="nl">start</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>        <span class="c1">// offset of first character</span>
  <span class="nx">end</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>          <span class="c1">// offset after last character</span>
  <span class="nx">isEmpty</span><span class="p">():</span> <span class="nx">boolean</span><span class="p">,</span>   <span class="c1">// true if end is not greater than start</span>
  <span class="nx">origStart</span><span class="p">:</span> <span class="p">?</span><span class="nx">number</span><span class="p">,</span>   <span class="c1">// set by CST#setOrigRanges(), source</span>
  <span class="nx">origEnd</span><span class="p">:</span> <span class="p">?</span><span class="nx">number</span>      <span class="c1">//   offsets for input with CRLF terminators</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Note</strong>: The <code>Node</code>, <code>Scalar</code> and other values referred to in this section are the CST representations of said objects, and are not the same as those used in preceding parts.</p>

<p>Actual values in the CST nodes are stored as <code>start</code>, <code>end</code> indices of the input string. This allows for memory consumption to be minimised by making string generation really lazy.</p>

<h3 style="clear:both">Node</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">context</span><span class="p">:</span> <span class="p">{</span>            <span class="c1">// not enumerable, to simplify logging</span>
    <span class="nl">atLineStart</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">,</span> <span class="c1">// is this node the first one on this line</span>
    <span class="nx">indent</span><span class="p">:</span> <span class="nx">number</span><span class="p">,</span>     <span class="c1">// current level of indentation (may be -1)</span>
    <span class="nx">root</span><span class="p">:</span> <span class="nx">CSTDocument</span><span class="p">,</span>  <span class="c1">// a reference to the parent document</span>
    <span class="nx">src</span><span class="p">:</span> <span class="nx">string</span>         <span class="c1">// the full original source</span>
  <span class="p">},</span>
  <span class="nx">error</span><span class="p">:</span> <span class="p">?</span><span class="nb">Error</span><span class="p">,</span>        <span class="c1">// if not null, indicates a parser failure</span>
  <span class="nx">props</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Range</span><span class="o">&gt;</span><span class="p">,</span>  <span class="c1">// anchors, tags and comments</span>
  <span class="nx">range</span><span class="p">:</span> <span class="nx">Range</span><span class="p">,</span>         <span class="c1">// span of context.src parsed into this node</span>
  <span class="nx">type</span><span class="p">:</span>                 <span class="c1">// specific node type</span>
    <span class="dl">'</span><span class="s1">ALIAS</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">BLOCK_FOLDED</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">BLOCK_LITERAL</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">COMMENT</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">DIRECTIVE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">DOCUMENT</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">FLOW_MAP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">FLOW_SEQ</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">MAP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">MAP_KEY</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">MAP_VALUE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">PLAIN</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">QUOTE_DOUBLE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">SEQ</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">SEQ_ITEM</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">value</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span>        <span class="c1">// if set to a non-null value, overrides</span>
                        <span class="c1">//   source value when stringified</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>     <span class="c1">// anchor, if set</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>    <span class="c1">// newline-delimited comment(s), if any</span>
  <span class="o">+</span><span class="nx">rangeAsLinePos</span><span class="p">:</span>      <span class="c1">// human-friendly source location</span>
    <span class="p">?{</span> <span class="na">start</span><span class="p">:</span> <span class="nx">LinePos</span><span class="p">,</span> <span class="na">end</span><span class="p">:</span> <span class="p">?</span><span class="nx">LinePos</span> <span class="p">},</span>
    <span class="c1">// LinePos here is { line: number, col: number }</span>
  <span class="o">+</span><span class="nx">rawValue</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span><span class="p">,</span>   <span class="c1">// an unprocessed slice of context.src</span>
                        <span class="c1">//   determining this node's value</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span>                 <span class="c1">// this node's tag, if set</span>
    <span class="kc">null</span> <span class="o">|</span> <span class="p">{</span> <span class="na">verbatim</span><span class="p">:</span> <span class="nx">string</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">handle</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="na">suffix</span><span class="p">:</span> <span class="nx">string</span> <span class="p">},</span>
  <span class="nx">toString</span><span class="p">():</span> <span class="nx">string</span>    <span class="c1">// a YAML string representation of this node</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">ContentNode</span> <span class="o">=</span>
  <span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nb">Map</span> <span class="o">|</span> <span class="nx">Seq</span> <span class="o">|</span> <span class="nx">FlowCollection</span>
</code></pre></div>
<p>Each node in the CST extends a common ancestor <code>Node</code>. Additional undocumented properties are available, but are likely only useful during parsing.</p>

<p>If a node has its <code>value</code> set, that will be used when re-stringifying (initially <code>undefined</code> for all nodes).</p>

<h3 style="clear:both">Scalars</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Alias</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="c1">// rawValue will contain the anchor without the * prefix</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ALIAS</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Scalar</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">PLAIN</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">QUOTE_DOUBLE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">BLOCK_FOLDED</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">BLOCK_LITERAL</span><span class="dl">'</span>
  <span class="o">+</span><span class="nx">strValue</span><span class="p">:</span> <span class="p">?</span><span class="nx">string</span> <span class="o">|</span>  <span class="c1">// unescaped string value</span>
    <span class="p">{</span> <span class="na">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="na">errors</span><span class="p">:</span> <span class="nx">YAMLSyntaxError</span><span class="p">[]</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Comment</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">COMMENT</span><span class="dl">'</span><span class="p">,</span>      <span class="c1">// PLAIN nodes may also be comment-only</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">rawValue</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">BlankLine</span> <span class="kd">extends</span> <span class="nx">Comment</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">BLANK_LINE</span><span class="dl">'</span><span class="p">,</span>   <span class="c1">// represents a single blank line, which</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="kc">null</span>        <span class="c1">//   may include whitespace</span>
<span class="p">}</span>
</code></pre></div>
<p>While <code>Alias</code>, <code>BlankLine</code> and <code>Comment</code> nodes are not technically scalars, they are parsed as such at this level.</p>

<p>Due to parsing differences, each scalar type is implemented using its own class.</p>

<h3 style="clear:both">Collections</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">MapItem</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">node</span><span class="p">:</span> <span class="nx">ContentNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MAP_KEY</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">MAP_VALUE</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nb">Map</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="c1">// implicit keys are not wrapped</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">MapItem</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">MAP</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">SeqItem</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">node</span><span class="p">:</span> <span class="nx">ContentNode</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">SEQ_ITEM</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Seq</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">SeqItem</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">SEQ</span><span class="dl">'</span>
<span class="p">}</span>

<span class="nx">type</span> <span class="nx">FlowChar</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">{</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">}</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">[</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">]</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">,</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">?</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">:</span><span class="dl">'</span>

<span class="kd">class</span> <span class="nx">FlowCollection</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">FlowChar</span> <span class="o">|</span> <span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Alias</span> <span class="o">|</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">FlowCollection</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">FLOW_MAP</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">FLOW_SEQ</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div>
<p>Block and flow collections are parsed rather differently, due to their representation differences.</p>

<p>An <code>Alias</code> or <code>Scalar</code> item directly within a <code>Map</code> should be treated as an implicit map key.</p>

<p>In actual code, <code>MapItem</code> and <code>SeqItem</code> are implemented as <code>CollectionItem</code>, and correspondingly <code>Map</code> and <code>Seq</code> as <code>Collection</code>.</p>

<h3 style="clear:both">Document Structure</h3>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Directive</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span>  <span class="c1">// should only be 'TAG' or 'YAML'</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">DIRECTIVE</span><span class="dl">'</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">parameters</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">CSTDocument</span> <span class="kd">extends</span> <span class="nx">Node</span> <span class="p">{</span>
  <span class="nl">directives</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">Comment</span> <span class="o">|</span> <span class="nx">Directive</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">contents</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ContentNode</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="nx">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">DOCUMENT</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">directivesEndMarker</span><span class="p">:</span> <span class="nx">Range</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="nx">documentEndMarker</span><span class="p">:</span> <span class="nx">Range</span> <span class="o">|</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">anchor</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">comment</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span>
  <span class="o">+</span><span class="nx">tag</span><span class="p">:</span> <span class="kc">null</span>
<span class="p">}</span>
</code></pre></div>
<p>The CST tree of a valid YAML document should have a single non-<code>Comment</code> <code>ContentNode</code> in its <code>contents</code> array. Multiple values indicates that the input is malformed in a way that made it impossible to determine the proper structure of the document. If <code>directivesEndMarker</code> or <code>documentEndMarker</code> are non-empty, the document includes (respectively) a directives-end marker <code>---</code> or a document-end marker <code>...</code> with the indicated range.</p>
<h1 id='errors'>Errors</h1>
<p>Nearly all errors and warnings produced by the <code>yaml</code> parser functions contain the following fields:</p>

<table><thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>name</td>
<td><code>string</code></td>
<td>One of <code>YAMLReferenceError</code>, <code>YAMLSemanticError</code>, <code>YAMLSyntaxError</code>, or <code>YAMLWarning</code></td>
</tr>
<tr>
<td>message</td>
<td><code>string</code></td>
<td>A human-readable description of the error</td>
</tr>
<tr>
<td>source</td>
<td><code>CST Node</code></td>
<td>The CST node at which this error or warning was encountered. Note that in particular <code>source.context</code> is likely to be a complex object and include some circular references.</td>
</tr>
</tbody></table>

<p>If the <code>prettyErrors</code> option is enabled, <code>source</code> is dropped from the errors and the following fields are added with summary information regarding the error&#39;s source node, if available:</p>

<table><thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>nodeType</td>
<td><code>string</code></td>
<td>A string constant identifying the type of node</td>
</tr>
<tr>
<td>range</td>
<td><code>{ start: number, end: ?number }</code></td>
<td>Character offset in the input string</td>
</tr>
<tr>
<td>linePos</td>
<td><code>{ start: LinePos, end: ?LinePos }</code></td>
<td>One-indexed human-friendly source location. <code>LinePos</code> here is <code>{ line: number, col: number }</code></td>
</tr>
</tbody></table>

<p>In rare cases, the library may produce a more generic error. In particular, <code>TypeError</code> may occur when parsing invalid input using the <code>json</code> schema, and <code>ReferenceError</code> when the <code>maxAliasCount</code> limit is enountered.</p>
<h2 id='yamlreferenceerror'>YAMLReferenceError</h2>
<p>An error resolving a tag or an anchor that is referred to in the source. It is likely that the contents of the <code>source</code> node have not been completely parsed into the document. Not used by the CST parser.</p>
<h2 id='yamlsemanticerror'>YAMLSemanticError</h2>
<p>An error related to the metadata of the document, or an error with limitations imposed by the YAML spec. The data contents of the document should be valid, but the metadata may be broken.</p>
<h2 id='yamlsyntaxerror'>YAMLSyntaxError</h2>
<p>A serious parsing error; the document contents will not be complete, and the CST is likely to be rather broken.</p>
<h2 id='yamlwarning'>YAMLWarning</h2>
<p>Not an error, but a spec-mandated warning about unsupported directives or a fallback resolution being used for a node with an unavailable tag. Not used by the CST parser.</p>
<h1 id='yaml-syntax'>YAML Syntax</h1>
<p>A YAML <em>schema</em> is a combination of a set of tags and a mechanism for resolving non-specific tags, i.e. values that do not have an explicit tag such as <code>!!int</code>. The <a href="#data-schemas">default schema</a> is the <code>&#39;core&#39;</code> schema, which is the recommended one for YAML 1.2. For YAML 1.0 and YAML 1.1 documents the default is <code>&#39;yaml-1.1&#39;</code>.</p>
<h2 id='tags'>Tags</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">"42"</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// '42'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">!!int "42"</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// 42</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="s2">`
%TAG ! tag:example.com,2018:app/
---
!foo 42
`</span><span class="p">)</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:example.com,2018:app/foo is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:str</span>
<span class="c1">// '42'</span>
</code></pre></div>
<p>The default prefix for YAML tags is <code>tag:yaml.org,2002:</code>, for which the shorthand <code>!!</code> is used when stringified. Shorthands for other prefixes may also be defined by document-specific directives, e.g. <code>!e!</code> or just <code>!</code> for <code>tag:example.com,2018:app/</code>, but this is not required to use a tag with a different prefix.</p>

<p>During parsing, unresolved tags should not result in errors (though they will be noted as <code>warnings</code>), with the tagged value being parsed according to the data type that it would have under automatic tag resolution rules. This should not result in any data loss, allowing such tags to be handled by the calling app.</p>

<p>In order to have <code>yaml</code> provide you with automatic parsing and stringification of non-standard data types, it will need to be configured with a suitable tag object. For more information, see <a href="#custom-tags">Custom Tags</a>.</p>

<p>The YAML 1.0 tag specification is <a href="#changes-from-yaml-1-0-to-1-1">slightly different</a> from that used in later versions, and implements prefixing shorthands rather differently.</p>
<h2 id='version-differences'>Version Differences</h2>
<p>This library&#39;s parser is based on the 1.2 version of the <a href="http://yaml.org/spec/1.2/spec.html">YAML spec</a>, which is mostly backwards-compatible with <a href="http://yaml.org/spec/1.1/">YAML 1.1</a> as well as <a href="http://yaml.org/spec/1.0/">YAML 1.0</a>. Some specific relaxations have been added for backwards compatibility, but if you encounter an issue please <a href="https://github.com/eemeli/yaml/issues">report it</a>.</p>
<h3 id='changes-from-yaml-1-1-to-1-2'>Changes from YAML 1.1 to 1.2</h3><div class="highlight"><pre class="highlight yaml tab-yaml"><code><span class="nt">%YAML</span> <span class="m">1.1</span>
<span class="nn">---</span>
<span class="na">true</span><span class="pi">:</span> <span class="s">Yes</span>
<span class="na">octal</span><span class="pi">:</span> <span class="m">014</span>
<span class="na">sexagesimal</span><span class="pi">:</span> <span class="s">3:25:45</span>
<span class="na">picture</span><span class="pi">:</span> <span class="kt">!!binary</span> <span class="pi">|</span>
  <span class="s">R0lGODlhDAAMAIQAAP//9/X</span>
  <span class="s">17unp5WZmZgAAAOfn515eXv</span>
  <span class="s">Pz7Y6OjuDg4J+fn5OTk6enp</span>
  <span class="s">56enmleECcgggoBADs=</span>
</code></pre></div><div class="highlight"><pre class="highlight javascript"><code><span class="p">{</span> <span class="nl">true</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nx">octal</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span>
  <span class="nx">sexagesimal</span><span class="p">:</span> <span class="mi">12345</span><span class="p">,</span>
  <span class="nx">picture</span><span class="p">:</span>
   <span class="nx">Buffer</span> <span class="p">[</span><span class="nb">Uint8Array</span><span class="p">]</span> <span class="p">[</span>
     <span class="mi">71</span><span class="p">,</span> <span class="mi">73</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="mi">97</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">132</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
     <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">247</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">245</span><span class="p">,</span> <span class="mi">238</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">233</span><span class="p">,</span> <span class="mi">229</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span>
     <span class="mi">102</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">231</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">243</span><span class="p">,</span>
     <span class="mi">243</span><span class="p">,</span> <span class="mi">237</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">142</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span> <span class="mi">159</span><span class="p">,</span>
     <span class="mi">159</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">147</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">167</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span> <span class="mi">158</span><span class="p">,</span>
     <span class="mi">105</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">130</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">59</span> <span class="p">]</span> <span class="p">}</span>
</code></pre></div>
<p>The most significant difference between YAML 1.1 and YAML 1.2 is the introduction of the core data schema as the recommended default, replacing the YAML 1.1 type library:</p>

<ul>
<li>Only <code>true</code> and <code>false</code> strings are parsed as booleans (including <code>True</code> and <code>TRUE</code>); <code>y</code>, <code>yes</code>, <code>on</code>, and their negative counterparts are parsed as strings.</li>
<li>Underlines <code>_</code> cannot be used within numerical values.</li>
<li>Octal values need a <code>0o</code> prefix; e.g. <code>010</code> is now parsed with the value 10 rather than 8.</li>
<li>The binary and sexagesimal integer formats have been dropped.</li>
<li>The <code>!!pairs</code>, <code>!!omap</code>, <code>!!set</code>, <code>!!timestamp</code> and <code>!!binary</code> types have been dropped.</li>
<li>The merge <code>&lt;&lt;</code> and value <code>=</code> special mapping keys have been removed.</li>
</ul>

<p>The other major change has been to make sure that YAML 1.2 is a valid superset of JSON. Additionally there are some minor differences between the parsing rules:</p>

<ul>
<li>The next-line <code>\x85</code>, line-separator <code>\u2028</code> and paragraph-separator <code>\u2029</code> characters are no longer considered line-break characters. Within scalar values, this means that next-line characters will not be included in the white-space normalisation. Using any of these outside scalar values is likely to result in errors during parsing. For a relatively robust solution, try replacing <code>\x85</code> and <code>\u2028</code> with <code>\n</code> and <code>\u2029</code> with <code>\n\n</code>.</li>
<li>Tag shorthands can no longer include any of the characters <code>,[]{}</code>, but can include <code>#</code>. To work around this, either fix your tag names or use verbatim tags.</li>
<li>Anchors can no longer include any of the characters <code>,[]{}</code>.</li>
<li>Inside double-quoted strings <code>\/</code> is now a valid escape for the <code>/</code> character.</li>
<li>Quoted content can include practically all Unicode characters.</li>
<li>Documents in streams are now independent of each other, and no longer inherit preceding document directives if they do not define their own.</li>
</ul>
<h3 id='changes-from-yaml-1-0-to-1-1'>Changes from YAML 1.0 to 1.1</h3><div class="highlight"><pre class="highlight plaintext"><code>%YAML:1.0
---
date: 2001-01-23
number: !int '123'
string: !str 123
pool: !!ball { number: 8 }
invoice: !domain.tld,2002/^invoice
  customers: !seq
    - !^customer
      given : Chris
      family : Dumars
</code></pre></div><div class="highlight"><pre class="highlight javascript"><code><span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:private.yaml.org,2002:ball is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag tag:domain.tld,2002/^invoice is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="c1">// YAMLWarning:</span>
<span class="c1">//   The tag ^customer is unavailable,</span>
<span class="c1">//   falling back to tag:yaml.org,2002:map</span>
<span class="p">{</span> <span class="nl">date</span><span class="p">:</span> <span class="dl">'</span><span class="s1">2001-01-23T00:00:00.000Z</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">number</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span>
  <span class="nx">string</span><span class="p">:</span> <span class="dl">'</span><span class="s1">123</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">pool</span><span class="p">:</span> <span class="p">{</span> <span class="nl">number</span><span class="p">:</span> <span class="mi">8</span> <span class="p">},</span>
  <span class="nx">invoice</span><span class="p">:</span> <span class="p">{</span> <span class="nl">customers</span><span class="p">:</span> <span class="p">[</span> <span class="p">{</span> <span class="na">given</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Chris</span><span class="dl">'</span><span class="p">,</span> <span class="na">family</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Dumars</span><span class="dl">'</span> <span class="p">}</span> <span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</code></pre></div>
<p>The most significant difference between these versions is the complete refactoring of the tag syntax:</p>

<ul>
<li>The <code>%TAG</code> directive has been added, along with the <code>!foo!</code> tag prefix shorthand notation.</li>
<li>The <code>^</code> character no longer enables tag prefixing.</li>
<li>The private vs. default scoping of <code>!</code> and <code>!!</code> tag prefixes has been switched around; <code>!!str</code> is now a default tag while <code>!bar</code> is an application-specific tag.</li>
<li>Verbatim <code>!&lt;baz&gt;</code> tag notation has been added.</li>
<li>The formal <code>tag:domain,date/path</code> format for tag names has been dropped as a requirement.</li>
</ul>

<p>Additionally, the formal description of the language describing the document structure has been completely refactored between these versions, but the described intent has not changed. Other changes include:</p>

<ul>
<li>A <code>\</code> escape has been added for the tab character, in addition to the pre-existing <code>\t</code></li>
<li>The <code>\^</code> escape has been removed</li>
<li>Directives now use a blank space <code>&#39; &#39;</code> rather than <code>:</code> as the separator between the name and its parameter/value.</li>
</ul>

<p><code>yaml</code> supports parsing and stringifying YAML 1.0 tags, but does not expand tags using the <code>^</code> notation. If this is something you&#39;d find useful, please file a <a href="https://github.com/eemeli/yaml/issues">GitHub issue</a> about it.</p>

      </div>
      <div class="dark-box">
      </div>
    </div>
  </body>
</html>
