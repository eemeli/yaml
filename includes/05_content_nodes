<h1 id='content-nodes'>Content Nodes</h1>
<p>After parsing, the <code>contents</code> value of each <code>YAML.Document</code> is the root of an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> of nodes representing the document (or <code>null</code> for an empty document).</p>

<p>Both scalar and collection values may have an <code>anchor</code> associated with them; this is rendered in the string representation with a <code>&amp;</code> prefix, so e.g. in <code>foo: &amp;aa bar</code>, the value <code>bar</code> has the anchor <code>aa</code>.
Anchors are used by <a href="#alias-nodes">Alias nodes</a> to allow for the same value to be used in multiple places in the document.
It is valid to have an anchor associated with a node even if it has no aliases.</p>
<h2 id='scalar-values'>Scalar Values</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">NodeBase</span> <span class="p">{</span>
  <span class="nx">comment</span><span class="p">?:</span> <span class="nx">string</span>        <span class="c1">// a comment on or immediately after this</span>
  <span class="nx">commentBefore</span><span class="p">?:</span> <span class="nx">string</span>  <span class="c1">// a comment before this</span>
  <span class="nx">range</span><span class="p">?:</span> <span class="p">[</span><span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="p">,</span> <span class="nx">number</span><span class="p">]</span>
      <span class="c1">// The `[start, value-end, node-end]` character offsets for the part</span>
      <span class="c1">// of the source parsed into this node (undefined if not parsed).</span>
      <span class="c1">// The `value-end` and `node-end` positions are themselves not</span>
      <span class="c1">// included in their respective ranges.</span>
  <span class="nx">spaceBefore</span><span class="p">?:</span> <span class="nx">boolean</span>
      <span class="c1">// a blank line before this node and its commentBefore</span>
  <span class="nx">tag</span><span class="p">?:</span> <span class="nx">string</span>       <span class="c1">// a fully qualified tag, if required</span>
  <span class="nx">clone</span><span class="p">():</span> <span class="nx">NodeBase</span>  <span class="c1">// a copy of this node</span>
  <span class="nx">toJSON</span><span class="p">():</span> <span class="nx">any</span>      <span class="c1">// a plain JS or JSON representation of this node</span>
<span class="p">}</span>
</code></pre></div>
<p>For scalar values, the <code>tag</code> will not be set unless it was explicitly defined in the source document; this also applies for unsupported tags that have been resolved using a fallback tag (string, <code>YAMLMap</code>, or <code>YAMLSeq</code>).</p>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Scalar</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">unknown</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">NodeBase</span> <span class="p">{</span>
  <span class="nx">anchor</span><span class="p">?:</span> <span class="nx">string</span>  <span class="c1">// an anchor associated with this node</span>
  <span class="nx">format</span><span class="p">?:</span> <span class="dl">'</span><span class="s1">BIN</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">HEX</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">OCT</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">TIME</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span>
      <span class="c1">// By default (undefined), numbers use decimal notation.</span>
      <span class="c1">// The YAML 1.2 core schema only supports 'HEX' and 'OCT'.</span>
  <span class="nx">type</span><span class="p">?:</span>
    <span class="dl">'</span><span class="s1">BLOCK_FOLDED</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">BLOCK_LITERAL</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">PLAIN</span><span class="dl">'</span> <span class="o">|</span>
    <span class="dl">'</span><span class="s1">QUOTE_DOUBLE</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span> <span class="o">|</span> <span class="kc">undefined</span>
  <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span>
<span class="p">}</span>
</code></pre></div>
<p>A parsed document&#39;s contents will have all of its non-object values wrapped in <code>Scalar</code> objects, which themselves may be in some hierarchy of <code>YAMLMap</code> and <code>YAMLSeq</code> collections.
However, this is not a requirement for the document&#39;s stringification, which is rather tolerant regarding its input values, and will use <a href="#creating-nodes"><code>doc.createNode()</code></a> when encountering an unwrapped value.</p>

<p>When stringifying, the node <code>type</code> will be taken into account by <code>!!str</code> and <code>!!binary</code> values, and ignored by other scalars.
On the other hand, <code>!!int</code> and <code>!!float</code> stringifiers will take <code>format</code> into account.</p>
<h2 id='collections'>Collections</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Pair</span><span class="o">&lt;</span><span class="nx">K</span> <span class="o">=</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">V</span> <span class="o">=</span> <span class="nx">unknown</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">key</span><span class="p">:</span> <span class="nx">K</span>    <span class="c1">// When parsed, key and value are always</span>
  <span class="na">value</span><span class="p">:</span> <span class="nx">V</span>  <span class="c1">// Node or null, but can be set to anything</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Collection</span> <span class="kd">extends</span> <span class="nx">NodeBase</span> <span class="p">{</span>
  <span class="nx">anchor</span><span class="p">?:</span> <span class="nx">string</span>  <span class="c1">// an anchor associated with this node</span>
  <span class="nx">flow</span><span class="p">?:</span> <span class="nx">boolean</span>   <span class="c1">// use flow style when stringifying this</span>
  <span class="nx">schema</span><span class="p">?:</span> <span class="nx">Schema</span>
  <span class="nx">addIn</span><span class="p">(</span><span class="nx">path</span><span class="p">:</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">):</span> <span class="k">void</span>
  <span class="nx">clone</span><span class="p">(</span><span class="nx">schema</span><span class="p">?:</span> <span class="nx">Schema</span><span class="p">):</span> <span class="nx">NodeBase</span>  <span class="c1">// a deep copy of this collection</span>
  <span class="nx">deleteIn</span><span class="p">(</span><span class="nx">path</span><span class="p">:</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="nx">getIn</span><span class="p">(</span><span class="nx">path</span><span class="p">:</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">keepScalar</span><span class="p">?:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">unknown</span>
  <span class="nx">hasIn</span><span class="p">(</span><span class="nx">path</span><span class="p">:</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="nx">setIn</span><span class="p">(</span><span class="nx">path</span><span class="p">:</span> <span class="nx">Iterable</span><span class="o">&lt;</span><span class="nx">unknown</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">):</span> <span class="k">void</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">YAMLMap</span><span class="o">&lt;</span><span class="nx">K</span> <span class="o">=</span> <span class="nx">unknown</span><span class="p">,</span> <span class="nx">V</span> <span class="o">=</span> <span class="nx">unknown</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Collection</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nx">Pair</span><span class="o">&lt;</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="o">&gt;</span><span class="p">[]</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">pair</span><span class="p">:</span> <span class="nx">Pair</span><span class="o">&lt;</span><span class="nx">K</span><span class="p">,</span> <span class="nx">V</span><span class="o">&gt;</span> <span class="o">|</span> <span class="p">{</span> <span class="na">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">;</span> <span class="nl">value</span><span class="p">:</span> <span class="nx">V</span> <span class="p">},</span> <span class="nx">overwrite</span><span class="p">?:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="k">void</span>
  <span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">keepScalar</span><span class="p">?:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">unknown</span>
  <span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">K</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">V</span><span class="p">):</span> <span class="k">void</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">YAMLSeq</span><span class="o">&lt;</span><span class="nx">T</span> <span class="o">=</span> <span class="nx">unknown</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Collection</span> <span class="p">{</span>
  <span class="nl">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span>
  <span class="k">delete</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">number</span> <span class="o">|</span> <span class="nx">Scalar</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">number</span> <span class="o">|</span> <span class="nx">Scalar</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">keepScalar</span><span class="p">?:</span> <span class="nx">boolean</span><span class="p">):</span> <span class="nx">unknown</span>
  <span class="nx">has</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">number</span> <span class="o">|</span> <span class="nx">Scalar</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">):</span> <span class="nx">boolean</span>
  <span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">:</span> <span class="nx">number</span> <span class="o">|</span> <span class="nx">Scalar</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">T</span><span class="p">):</span> <span class="k">void</span>
<span class="p">}</span>
</code></pre></div>
<p>Within all YAML documents, two forms of collections are supported: sequential <code>YAMLSeq</code> collections and key-value <code>YAMLMap</code> collections.
The JavaScript representations of these collections both have an <code>items</code> array, which may (<code>YAMLSeq</code>) or must (<code>YAMLMap</code>) consist of <code>Pair</code> objects that contain a <code>key</code> and a <code>value</code> of any type, including <code>null</code>.
The <code>items</code> array of a <code>YAMLSeq</code> object may contain values of any type.</p>

<p>When stringifying collections, by default block notation will be used.
Flow notation will be selected if <code>flow</code> is <code>true</code>, the collection is within a surrounding flow collection, or if the collection is in an implicit key.</p>

<p>The <code>yaml-1.1</code> schema includes <a href="https://yaml.org/type/index.html">additional collections</a> that are based on <code>YAMLMap</code> and <code>YAMLSeq</code>: <code>OMap</code> and <code>Pairs</code> are sequences of <code>Pair</code> objects (<code>OMap</code> requires unique keys &amp; corresponds to the JS Map object), and <code>Set</code> is a map of keys with null values that corresponds to the JS Set object.</p>

<p>All of the collections provide the following accessor methods:</p>

<table><thead>
<tr>
<th>Method</th>
<th>Returns</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>add(value), addIn(path, value)</td>
<td><code>void</code></td>
<td>Adds a value to the collection. For <code>!!map</code> and <code>!!omap</code> the value must be a Pair instance or a <code>{ key, value }</code> object, which may not have a key that already exists in the map.</td>
</tr>
<tr>
<td>delete(key), deleteIn(path)</td>
<td><code>boolean</code></td>
<td>Removes a value from the collection. Returns <code>true</code> if the item was found and removed.</td>
</tr>
<tr>
<td>get(key,&nbsp;[keep]), getIn(path,&nbsp;[keep])</td>
<td><code>any</code></td>
<td>Returns value at <code>key</code>, or <code>undefined</code> if not found. By default unwraps scalar values from their surrounding node; to disable set <code>keep</code> to <code>true</code> (collections are always returned intact).</td>
</tr>
<tr>
<td>has(key), hasIn(path)</td>
<td><code>boolean</code></td>
<td>Checks if the collection includes a value with the key <code>key</code>.</td>
</tr>
<tr>
<td>set(key, value), setIn(path, value)</td>
<td><code>any</code></td>
<td>Sets a value in this collection. For <code>!!set</code>, <code>value</code> needs to be a boolean to add/remove the item from the set. When overwriting a <code>Scalar</code> value with a scalar, the original node is retained.</td>
</tr>
</tbody></table>

<!-- prettier-ignore -->
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">({</span> <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">b</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">})</span> <span class="c1">// { a: 1, b: [ 2, 3 ] }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">({</span> <span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="mi">4</span> <span class="p">})</span> <span class="c1">// { a: 1, b: [ 2, 3 ], c: 4 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">addIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">],</span> <span class="mi">5</span><span class="p">)</span>             <span class="c1">// { a: 1, b: [ 2, 3, 5 ], c: 4 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="mi">42</span><span class="p">)</span>                <span class="c1">// { a: 1, b: [ 2, 3, 5 ], c: 42 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">setIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">x</span><span class="dl">'</span><span class="p">])</span> <span class="c1">// Error: Expected YAML collection at c. Remaining path: x</span>
<span class="nx">doc</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span>                 <span class="c1">// { a: 1, b: [ 2, 3, 5 ] }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">deleteIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>          <span class="c1">// { a: 1, b: [ 2, 5 ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 1</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="c1">// Scalar { value: 1 }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 5</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">createNode</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// true</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// false</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">hasIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">])</span> <span class="c1">// true</span>
</code></pre></div>
<p>For all of these methods, the keys may be nodes or their wrapped scalar values (i.e. <code>42</code> will match <code>Scalar { value: 42 }</code>).
Keys for <code>!!seq</code> should be positive integers, or their string representations.
<code>add()</code> and <code>set()</code> do not automatically call <code>doc.createNode()</code> to wrap the value.</p>

<p>Each of the methods also has a variant that requires an iterable as the first parameter, and allows fetching or modifying deeper collections.
If any intermediate node in <code>path</code> is a scalar rather than a collection, an error will be thrown.
If any of the intermediate collections is not found:</p>

<ul>
<li><code>getIn</code> and <code>hasIn</code> will return <code>undefined</code> or <code>false</code> (respectively)</li>
<li><code>addIn</code> and <code>setIn</code> will create missing collections; non-negative integer keys will create sequences, all other keys create maps</li>
<li><code>deleteIn</code> will throw an error</li>
</ul>

<p>Note that for <code>addIn</code> the path argument points to the collection rather than the item; for maps its <code>value</code> should be a <code>Pair</code> or an object with <code>{ key, value }</code> fields.</p>
<h2 id='alias-nodes'>Alias Nodes</h2>
<!-- prettier-ignore -->
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">class</span> <span class="nx">Alias</span> <span class="kd">extends</span> <span class="nx">NodeBase</span> <span class="p">{</span>
  <span class="nl">source</span><span class="p">:</span> <span class="nx">string</span>
  <span class="nx">resolve</span><span class="p">(</span><span class="nx">doc</span><span class="p">:</span> <span class="nx">Document</span><span class="p">):</span> <span class="nx">Scalar</span> <span class="o">|</span> <span class="nx">YAMLMap</span> <span class="o">|</span> <span class="nx">YAMLSeq</span> <span class="o">|</span> <span class="kc">undefined</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">[ &amp;x { X: 42 }, Y, *x ]</span><span class="dl">'</span><span class="p">)</span>
  <span class="c1">// =&gt; [ { X: 42 }, 'Y', { X: 42 } ]</span>
<span class="nx">obj</span><span class="p">[</span><span class="mi">2</span><span class="p">].</span><span class="nx">Z</span> <span class="o">=</span> <span class="mi">13</span>
  <span class="c1">// =&gt; [ { X: 42, Z: 13 }, 'Y', { X: 42, Z: 13 } ]</span>
<span class="nx">YAML</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
  <span class="c1">// - &amp;a1</span>
  <span class="c1">//   X: 42</span>
  <span class="c1">//   Z: 13</span>
  <span class="c1">// - Y</span>
  <span class="c1">// - *a1</span>
</code></pre></div>
<p><code>Alias</code> nodes provide a way to include a single node in multiple places in a document; the <code>source</code> of an alias node must be a preceding anchor in the document.
Circular references are fully supported, and where possible the JS representation of alias nodes will be the actual source object.
For ease of use, alias nodes also provide a <code>resolve(doc)</code> method to dreference its source node.</p>

<p>When nodes are constructed from JS structures (e.g. during <code>YAML.stringify()</code>), multiple references to the same object will result in including an autogenerated anchor at its first instance, and alias nodes to that anchor at later references.</p>
<h2 id='creating-nodes'>Creating Nodes</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">Document</span><span class="p">([</span><span class="dl">'</span><span class="s1">some</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">values</span><span class="dl">'</span><span class="p">])</span>
<span class="c1">// Document {</span>
<span class="c1">//   contents:</span>
<span class="c1">//     YAMLSeq {</span>
<span class="c1">//       items:</span>
<span class="c1">//        [ Scalar { value: 'some' },</span>
<span class="c1">//          Scalar { value: 'values' } ] } }</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">createNode</span><span class="p">({</span> <span class="na">balloons</span><span class="p">:</span> <span class="mi">99</span> <span class="p">})</span>
<span class="c1">// YAMLMap {</span>
<span class="c1">//   items:</span>
<span class="c1">//    [ Pair {</span>
<span class="c1">//        key: Scalar { value: 'balloons' },</span>
<span class="c1">//        value: Scalar { value: 99 } } ] }</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">).</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> A commented item</span><span class="dl">'</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// - some # A commented item</span>
<span class="c1">// - values</span>
<span class="c1">// - balloons: 99</span>
</code></pre></div><h4 id='doc-createnode-value-replacer-options-node'><code>doc.createNode(value, replacer?, options?): Node</code></h4>
<p>To create a new node, use the <code>createNode(value, options?)</code> document method.
This will recursively wrap any input with appropriate <code>Node</code> containers.
Generic JS <code>Object</code> values as well as <code>Map</code> and its descendants become mappings, while arrays and other iterable objects result in sequences.
With <code>Object</code>, entries that have an <code>undefined</code> value are dropped.</p>

<p>If <code>value</code> is already a <code>Node</code> instance, it will be directly returned.
To create a copy of a node, use instead the <code>node.clone()</code> method.
For collections, the method accepts a single <code>Schema</code> argument,
which allows overwriting the original&#39;s <code>schema</code> value.</p>

<p>Use a <code>replacer</code> to apply a replacer array or function, following the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#The_replacer_parameter">JSON implementation</a>.
To force flow styling on a collection, use the <code>flow: true</code> option.
For all available options, see the <a href="#createnode-options">CreateNode Options</a> section.</p>

<p>The primary purpose of this method is to enable attaching comments or other metadata to a value, or to otherwise exert more fine-grained control over the stringified output.
To that end, you&#39;ll need to assign its return value to the <code>contents</code> of a document (or somewhere within said contents), as the document&#39;s schema is required for YAML string output.
If you&#39;re not interested in working with such metadata, document <code>contents</code> may also include non-<code>Node</code> values at any level.</p>

<h4 style="clear:both"><code>doc.createAlias(node, name?): Alias</code></h4>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">alias</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">createAlias</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span> <span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">alias</span><span class="p">)</span>
<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// - some # A commented item</span>
<span class="c1">// - &amp;foo values</span>
<span class="c1">// - balloons: 99</span>
<span class="c1">// - *foo</span>
</code></pre></div>
<p>Create a new <code>Alias</code> node, ensuring that the target <code>node</code> has the required anchor.
If <code>node</code> already has an anchor, <code>name</code> is ignored.
Otherwise, the <code>node.anchor</code> value will be set to <code>name</code>, or if an anchor with that name is already present in the document, <code>name</code> will be used as a prefix for a new unique anchor.
If <code>name</code> is undefined, the generated anchor will use &#39;a&#39; as a prefix.</p>

<p>You should make sure to only add alias nodes to the document after the nodes to which they refer, or the document&#39;s YAML stringification will fail.</p>

<h4 style="clear:both"><code>new YAMLMap(), new YAMLSeq(), doc.createPair(key, value): Pair</code></h4>
<div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Document</span><span class="p">,</span> <span class="nx">YAMLSeq</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Document</span><span class="p">(</span><span class="k">new</span> <span class="nx">YAMLSeq</span><span class="p">())</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span> <span class="o">=</span> <span class="p">[</span>
  <span class="dl">'</span><span class="s1">some values</span><span class="dl">'</span><span class="p">,</span>
  <span class="mi">42</span><span class="p">,</span>
  <span class="p">{</span> <span class="na">including</span><span class="p">:</span> <span class="dl">'</span><span class="s1">objects</span><span class="dl">'</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="dl">'</span><span class="s1">a string</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">]</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">createPair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a number</span><span class="dl">'</span><span class="p">))</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// - some values</span>
<span class="c1">// - 42</span>
<span class="c1">// - "3": a string</span>
<span class="c1">//   including: objects</span>
<span class="c1">// - 1: a number</span>
</code></pre></div>
<p>To construct a <code>YAMLSeq</code> or <code>YAMLMap</code>, use <code>new Document()</code> or <code>doc.createNode()</code> with array, object or iterable input, or create the collections directly by importing the classes from <code>yaml</code>.</p>

<p>Once created, normal array operations may be used to modify the <code>items</code> array.
New <code>Pair</code> objects may created either by importing the class from <code>yaml</code> and using its <code>new Pair(key, value)</code> constructor, or by using the <code>doc.createPair(key, value, options?)</code> method.
The latter will recursively wrap the <code>key</code> and <code>value</code> as nodes, and accepts the same options as <code>doc.createNode()</code></p>
<h2 id='identifying-nodes'>Identifying Nodes</h2><div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span>
  <span class="nx">isAlias</span><span class="p">,</span>
  <span class="nx">isCollection</span><span class="p">,</span> <span class="c1">// map or seq</span>
  <span class="nx">isDocument</span><span class="p">,</span>
  <span class="nx">isMap</span><span class="p">,</span>
  <span class="nx">isNode</span><span class="p">,</span> <span class="c1">// alias, scalar, map or seq</span>
  <span class="nx">isPair</span><span class="p">,</span>
  <span class="nx">isScalar</span><span class="p">,</span>
  <span class="nx">isSeq</span>
<span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Document</span><span class="p">({</span> <span class="na">foo</span><span class="p">:</span> <span class="p">[</span><span class="mi">13</span><span class="p">,</span> <span class="mi">42</span><span class="p">]</span> <span class="p">})</span>
<span class="nx">isDocument</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="o">===</span> <span class="kc">true</span>
<span class="nx">isNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span> <span class="o">===</span> <span class="kc">false</span>
<span class="nx">isMap</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">)</span> <span class="o">===</span> <span class="kc">true</span>
<span class="nx">isNode</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">)</span> <span class="o">===</span> <span class="kc">true</span>
<span class="nx">isPair</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">contents</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">===</span> <span class="kc">true</span>
<span class="nx">isCollection</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">))</span> <span class="o">===</span> <span class="kc">true</span>
<span class="nx">isScalar</span><span class="p">(</span><span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="dl">'</span><span class="s1">foo</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">===</span> <span class="kc">true</span>
</code></pre></div><h4 id='isalias-x-unknown-boolean'><code>isAlias(x: unknown): boolean</code></h4><h4 id='iscollection-x-unknown-boolean'><code>isCollection(x: unknown): boolean</code></h4><h4 id='isdocument-x-unknown-boolean'><code>isDocument(x: unknown): boolean</code></h4><h4 id='ismap-x-unknown-boolean'><code>isMap(x: unknown): boolean</code></h4><h4 id='isnode-x-unknown-boolean'><code>isNode(x: unknown): boolean</code></h4><h4 id='ispair-x-unknown-boolean'><code>isPair(x: unknown): boolean</code></h4><h4 id='isscalar-x-unknown-boolean'><code>isScalar(x: unknown): boolean</code></h4><h4 id='isseq-x-unknown-boolean'><code>isSeq(x: unknown): boolean</code></h4>
<p>To find out what you&#39;ve got, a family of custom type guard functions is provided.
These should be preferred over other methods such as <code>instanceof</code> checks, as they&#39;ll work even if the nodes have been created by a different instance of the library.</p>

<p>Internally, node identification uses property symbols that are set on instances during their construction.</p>
<h2 id='modifying-nodes'>Modifying Nodes</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s2">`
  - some values
  - 42
  - "3": a string
    including: objects
  - 1: a number
`</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">obs</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="nx">getIn</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">including</span><span class="dl">'</span><span class="p">],</span> <span class="kc">true</span><span class="p">)</span>
<span class="nx">obs</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">QUOTE_DOUBLE</span><span class="dl">'</span>

<span class="nx">YAML</span><span class="p">.</span><span class="nx">visit</span><span class="p">(</span><span class="nx">doc</span><span class="p">,</span> <span class="p">{</span>
  <span class="nx">Pair</span><span class="p">(</span><span class="nx">_</span><span class="p">,</span> <span class="nx">pair</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">pair</span><span class="p">.</span><span class="nx">key</span> <span class="o">&amp;&amp;</span> <span class="nx">pair</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">)</span> <span class="k">return</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">visit</span><span class="p">.</span><span class="nx">REMOVE</span>
  <span class="p">},</span>
  <span class="nx">Scalar</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span>
      <span class="nx">key</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">key</span><span class="dl">'</span> <span class="o">&amp;&amp;</span>
      <span class="k">typeof</span> <span class="nx">node</span><span class="p">.</span><span class="nx">value</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span> <span class="o">&amp;&amp;</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">type</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">PLAIN</span><span class="dl">'</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="nx">node</span><span class="p">.</span><span class="nx">type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">})</span>

<span class="nb">String</span><span class="p">(</span><span class="nx">doc</span><span class="p">)</span>
<span class="c1">// - 'some values'</span>
<span class="c1">// - 42</span>
<span class="c1">// - including: "objects"</span>
<span class="c1">// - 1: 'a number'</span>
</code></pre></div>
<p>In general, it&#39;s safe to modify nodes manually, e.g. splicing the <code>items</code> array of a <code>YAMLMap</code> or setting its <code>flow</code> value to <code>true</code>.
For operations on nodes at a known location in the tree, it&#39;s probably easiest to use <code>doc.getIn(path, true)</code> to access them.
For more complex or general operations, a visitor API is provided:</p>
<h4 id='yaml-visit-node-visitor'><code>YAML.visit(node, visitor)</code></h4>
<p>Apply a visitor to an AST node or document.</p>

<p>Walks through the tree (depth-first) starting from <code>node</code>, calling a <code>visitor</code> function with three arguments:</p>

<ul>
<li><code>key</code>: For sequence values and map <code>Pair</code>, the node&#39;s index in the collection.
Within a <code>Pair</code>, <code>&#39;key&#39;</code> or <code>&#39;value&#39;</code>, correspondingly.
<code>null</code> for the root node.</li>
<li><code>node</code>: The current node.</li>
<li><code>path</code>: The ancestry of the current node.</li>
</ul>

<p>The return value of the visitor may be used to control the traversal:</p>

<ul>
<li><code>undefined</code> (default): Do nothing and continue</li>
<li><code>YAML.visit.SKIP</code>: Do not visit the children of this node, continue with next sibling</li>
<li><code>YAML.visit.BREAK</code>: Terminate traversal completely</li>
<li><code>YAML.visit.REMOVE</code>: Remove the current node, then continue with the next one</li>
<li><code>Node</code>: Replace the current node, then continue by visiting it</li>
<li><code>number</code>: While iterating the items of a sequence or map, set the index of the next step.
This is useful especially if the index of the current node has changed.</li>
</ul>

<p>If <code>visitor</code> is a single function, it will be called with all values encountered in the tree, including e.g. <code>null</code> values.
Alternatively, separate visitor functions may be defined for each <code>Map</code>, <code>Pair</code>, <code>Seq</code>, <code>Alias</code> and <code>Scalar</code> node.</p>
<h2 id='comments-and-blank-lines'>Comments and Blank Lines</h2><div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">doc</span> <span class="o">=</span> <span class="nx">YAML</span><span class="p">.</span><span class="nx">parseDocument</span><span class="p">(</span><span class="s2">`
# This is YAML.
---
it has:

  - an array

  - of values
`</span><span class="p">)</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toJS</span><span class="p">()</span> <span class="c1">// { 'it has': [ 'an array', 'of values' ] }</span>
<span class="nx">doc</span><span class="p">.</span><span class="nx">commentBefore</span> <span class="c1">// ' This is YAML.'</span>

<span class="kd">const</span> <span class="nx">seq</span> <span class="o">=</span> <span class="nx">doc</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">it has</span><span class="dl">'</span><span class="p">)</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">spaceBefore</span> <span class="c1">// true</span>

<span class="nx">seq</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> item comment</span><span class="dl">'</span>
<span class="nx">seq</span><span class="p">.</span><span class="nx">comment</span> <span class="o">=</span> <span class="dl">'</span><span class="s1"> collection end comment</span><span class="dl">'</span>

<span class="nx">doc</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
<span class="c1">// # This is YAML.</span>
<span class="c1">//</span>
<span class="c1">// it has:</span>
<span class="c1">//</span>
<span class="c1">//   - an array # item comment</span>
<span class="c1">//</span>
<span class="c1">//   - of values</span>
<span class="c1">//   # collection end comment</span>
</code></pre></div>
<p>A primary differentiator between this and other YAML libraries is the ability to programmatically handle comments, which according to <a href="http://yaml.org/spec/1.2/spec.html#id2767100">the spec</a>
&quot;must not have any effect on the serialization tree or representation graph. In particular, comments are not associated with a particular node.&quot;
Similarly to comments, the YAML spec instructs non-content blank lines to be discarded.</p>

<p>This library <em>does</em> allow comments and blank lines to be handled programmatically, and does attach them to particular nodes (most often, the following node).
Each <code>Scalar</code>, <code>Map</code>, <code>Seq</code> and the <code>Document</code> itself has <code>comment</code>, <code>commentBefore</code> members that may be set to a stringifiable value, and a <code>spaceBefore</code> boolean to add an empty line before the comment.</p>

<p>The string contents of comments are not processed by the library, except for merging adjacent comment and blank lines together.
Document comments will be separated from the rest of the document by a blank line.
In the node member values, comment lines terminating with the <code>#</code> indicator are represented by a single space, while completely empty lines are represented as empty strings.</p>

<p>Scalar block values with &quot;keep&quot; chomping (i.e. with <code>+</code> in their header) consider any trailing empty lines to be a part of their content, so the following node&#39;s <code>spaceBefore</code> or <code>commentBefore</code> with leading whitespace is ignored.</p>

<p><strong>Note</strong>: Due to implementation details, the library&#39;s comment handling is not completely stable, in particular for trailing comments.
When creating, writing, and then reading a YAML file, comments may sometimes be associated with a different node.</p>
