<h1 id='options'>Options</h1><div class="highlight"><pre class="highlight javascript"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">parse</span><span class="p">,</span> <span class="nx">stringify</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">yaml</span><span class="dl">'</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">number: 999</span><span class="dl">'</span><span class="p">)</span>
<span class="c1">// { number: 999 }</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">number: 999</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">intAsBigInt</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
<span class="c1">// { number: 999n }</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">number: 999</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failsafe</span><span class="dl">'</span> <span class="p">})</span>
<span class="c1">// { number: '999' }</span>
</code></pre></div>
<p>The options supported by various <code>yaml</code> features are split into various categories, depending on how and where they are used.
Options in various categories do not overlap, so it&#39;s fine to use a single &quot;bag&quot; of options and pass it to each function or method.</p>
<h2 id='parse-options'>Parse Options</h2>
<p>Parse options affect the parsing and composition of a YAML Document from it source.</p>

<p>Used by: <code>parse()</code>, <code>parseDocument()</code>, <code>parseAllDocuments()</code>, <code>new Composer()</code>, and <code>new Document()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>intAsBigInt</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Whether integers should be parsed into <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a> rather than <code>number</code> values.</td>
</tr>
<tr>
<td>keepSourceTokens</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Include a <code>srcToken</code> value on each parsed <code>Node</code>, containing the <a href="#working-with-cst-tokens">CST token</a> that was composed into this node.</td>
</tr>
<tr>
<td>lineCounter</td>
<td><code>LineCounter</code></td>
<td></td>
<td>If set, newlines will be tracked, to allow for <code>lineCounter.linePos(offset)</code> to provide the <code>{ line, col }</code> positions within the input.</td>
</tr>
<tr>
<td>prettyErrors</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>Include line/col position in errors, along with an extract of the source string.</td>
</tr>
<tr>
<td>strict</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>When parsing, do not ignore errors <a href="#silencing-errors-and-warnings">required</a> by the YAML 1.2 spec, but caused by unambiguous content.</td>
</tr>
<tr>
<td>uniqueKeys</td>
<td><code>boolean ⎮ (a, b) =&gt; boolean</code></td>
<td><code>true</code></td>
<td>Whether key uniqueness is checked, or customised. If set to be a function, it will be passed two parsed nodes and should return a boolean value indicating their equality.</td>
</tr>
</tbody></table>
<h2 id='document-options'>Document Options</h2>
<p>Document options are relevant for operations on the <code>Document</code> object, which makes them relevant for both conversion directions.</p>

<p>Used by: <code>parse()</code>, <code>parseDocument()</code>, <code>parseAllDocuments()</code>, <code>stringify()</code>, <code>new Composer()</code>, and <code>new Document()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>logLevel</td>
<td><code>&#39;warn&#39; ⎮ &#39;error&#39; ⎮</code> <code>&#39;silent&#39;</code></td>
<td><code>&#39;warn&#39;</code></td>
<td>Control the verbosity of <code>parse()</code>. Set to <code>&#39;error&#39;</code> to silence warnings, and to <code>&#39;silent&#39;</code> to also silence most errors (not recommended).</td>
</tr>
<tr>
<td>version</td>
<td><code>&#39;1.1&#39; ⎮ &#39;1.2&#39;</code></td>
<td><code>&#39;1.2&#39;</code></td>
<td>The YAML version used by documents without a <code>%YAML</code> directive.</td>
</tr>
</tbody></table>

<p>By default, the library will emit warnings as required by the YAML spec during parsing.
If you&#39;d like to silence these, set the <code>logLevel</code> option to <code>&#39;error&#39;</code>.</p>
<h2 id='schema-options'>Schema Options</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 3 (Using YAML 1.2 core schema by default)</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failsafe</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// '3'</span>

<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'No'</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">json</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// SyntaxError: Unresolved plain scalar "No"</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">schema</span><span class="p">:</span> <span class="dl">'</span><span class="s1">yaml-1.1</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// false</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">No</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">version</span><span class="p">:</span> <span class="dl">'</span><span class="s1">1.1</span><span class="dl">'</span> <span class="p">})</span> <span class="c1">// false</span>
</code></pre></div>
<p>Schema options determine the types of values that the document supports.</p>

<p>Aside from defining the language structure, the YAML 1.2 spec defines a number of different <em>schemas</em> that may be used.
The default is the <a href="http://yaml.org/spec/1.2/spec.html#id2804923"><code>core</code></a> schema, which is the most common one.
The <a href="http://yaml.org/spec/1.2/spec.html#id2803231"><code>json</code></a> schema is effectively the minimum schema required to parse JSON; both it and the core schema are supersets of the minimal <a href="http://yaml.org/spec/1.2/spec.html#id2802346"><code>failsafe</code></a> schema.</p>

<p>The <code>yaml-1.1</code> schema matches the more liberal <a href="http://yaml.org/type/">YAML 1.1 types</a> (also used by YAML 1.0), including binary data and timestamps as distinct tags.
This schema accepts a greater variance in scalar values (with e.g. <code>&#39;No&#39;</code> being parsed as <code>false</code> rather than a string value).
The <code>!!value</code> and <code>!!yaml</code> types are not supported.</p>

<p>Used by: <code>parse()</code>, <code>parseDocument()</code>, <code>parseAllDocuments()</code>, <code>stringify()</code>, <code>new Composer()</code>, <code>new Document()</code>, and <code>doc.setSchema()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>compat</td>
<td><code>string ⎮ Tag[] ⎮ null</code></td>
<td><code>null</code></td>
<td>When parsing, warn about compatibility issues with the given schema. When stringifying, use scalar styles that are parsed correctly by the <code>compat</code> schema as well as the actual schema.</td>
</tr>
<tr>
<td>customTags</td>
<td><code>Tag[] ⎮ function</code></td>
<td></td>
<td>Array of <a href="#custom-data-types">additional tags</a> to include in the schema</td>
</tr>
<tr>
<td>merge</td>
<td><code>boolean</code></td>
<td>1.1:&nbsp;<code>true</code> 1.2:&nbsp;<code>false</code></td>
<td>Enable support for <code>&lt;&lt;</code> merge keys. Default value depends on YAML version.</td>
</tr>
<tr>
<td>resolveKnownTags</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>When using the <code>&#39;core&#39;</code> schema, support parsing values with these explicit <a href="https://yaml.org/type/">YAML 1.1 tags</a>: <code>!!binary</code>, <code>!!omap</code>, <code>!!pairs</code>, <code>!!set</code>, <code>!!timestamp</code>. By default <code>true</code>.</td>
</tr>
<tr>
<td>schema</td>
<td><code>string</code></td>
<td>1.1:&nbsp;<code>&#39;yaml-1.1&#39;</code> 1.2:&nbsp;<code>&#39;core&#39;</code></td>
<td>The base schema to use. Default value depends on YAML version. Built-in support is provided for <code>&#39;core&#39;</code>, <code>&#39;failsafe&#39;</code>, <code>&#39;json&#39;</code>, and <code>&#39;yaml-1.1&#39;</code>. If using another value, <code>customTags</code> must be an array of tags.</td>
</tr>
<tr>
<td>sortMapEntries</td>
<td><code>boolean ⎮</code> <code>(a, b: Pair) =&gt; number</code></td>
<td><code>false</code></td>
<td>When stringifying, sort map entries. If <code>true</code>, sort by comparing key values using the native less-than <code>&lt;</code> operator.</td>
</tr>
<tr>
<td>toStringDefaults</td>
<td><code>ToStringOptions</code></td>
<td></td>
<td>Override default values for <code>toString()</code> options.</td>
</tr>
</tbody></table>
<div class="highlight"><pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">src</span> <span class="o">=</span> <span class="s2">`
  source: &amp;base { a: 1, b: 2 }
  target:
    &lt;&lt;: *base
    b: base`</span>
<span class="kd">const</span> <span class="nx">mergeResult</span> <span class="o">=</span> <span class="nx">parse</span><span class="p">(</span><span class="nx">src</span><span class="p">,</span> <span class="p">{</span> <span class="na">merge</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span>
<span class="nx">mergeResult</span><span class="p">.</span><span class="nx">target</span>
<span class="c1">// { a: 1, b: 'base' }</span>
</code></pre></div>
<p><strong>Merge</strong> keys are a <a href="http://yaml.org/type/merge.html">YAML 1.1 feature</a> that is not a part of the 1.2 spec.
To use a merge key, assign a map or its alias or an array of such as the value of a <code>&lt;&lt;</code> key in a mapping.
Multiple merge keys may be used on the same map, with earlier values taking precedence over latter ones, in case both define a value for the same key.</p>
<h2 id='createnode-options'>CreateNode Options</h2>
<p>Used by: <code>stringify()</code>, <code>new Document()</code>, <code>doc.createNode()</code>, and <code>doc.createPair()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>aliasDuplicateObjects</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>During node construction, use anchors and aliases to keep strictly equal non-null objects as equivalent in YAML.</td>
</tr>
<tr>
<td>anchorPrefix</td>
<td><code>string</code></td>
<td><code>&#39;a&#39;</code></td>
<td>Default prefix for anchors, resulting in anchors <code>a1</code>, <code>a2</code>, ... by default.</td>
</tr>
<tr>
<td>flow</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Force the top-level collection node to use flow style.</td>
</tr>
<tr>
<td>keepUndefined</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Keep <code>undefined</code> object values when creating mappings and return a Scalar node when stringifying <code>undefined</code>.</td>
</tr>
<tr>
<td>tag</td>
<td><code>string</code></td>
<td></td>
<td>Specify the top-level collection type, e.g. <code>&#39;!!omap&#39;</code>. Note that this requires the corresponding tag to be available in this document&#39;s schema.</td>
</tr>
</tbody></table>
<h2 id='tojs-options'>ToJS Options</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{[1, 2]: many}</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// { '[ 1, 2 ]': 'many' }</span>
<span class="nx">parse</span><span class="p">(</span><span class="dl">'</span><span class="s1">{[1, 2]: many}</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">mapAsMap</span><span class="p">:</span> <span class="kc">true</span> <span class="p">})</span> <span class="c1">// Map { [ 1, 2 ] =&gt; 'many' }</span>
</code></pre></div>
<p>These options influence how the document is transformed into &quot;native&quot; JavaScript representation.</p>

<p>Used by: <code>parse()</code> and <code>doc.toJS()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>mapAsMap</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Use Map rather than Object to represent mappings.</td>
</tr>
<tr>
<td>maxAliasCount</td>
<td><code>number</code></td>
<td><code>100</code></td>
<td>Prevent <a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">exponential entity expansion attacks</a> by limiting data aliasing; set to <code>-1</code> to disable checks; <code>0</code> disallows all alias nodes.</td>
</tr>
<tr>
<td>onAnchor</td>
<td><code>(value: any, count: number) =&gt; void</code></td>
<td></td>
<td>Optional callback for each aliased anchor in the document.</td>
</tr>
<tr>
<td>reviver</td>
<td><code>(key: any, value: any) =&gt; any</code></td>
<td></td>
<td>Optionally apply a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter">reviver function</a> to the output, following the JSON specification but with appropriate extensions for handling <code>Map</code> and <code>Set</code>.</td>
</tr>
</tbody></table>
<h2 id='tostring-options'>ToString Options</h2><div class="highlight"><pre class="highlight javascript"><code><span class="nx">stringify</span><span class="p">(</span>
  <span class="p">{</span> <span class="na">this</span><span class="p">:</span> <span class="kc">null</span><span class="p">,</span> <span class="na">that</span><span class="p">:</span> <span class="dl">'</span><span class="s1">value</span><span class="dl">'</span> <span class="p">},</span>
  <span class="p">{</span> <span class="na">defaultStringType</span><span class="p">:</span> <span class="dl">'</span><span class="s1">QUOTE_SINGLE</span><span class="dl">'</span><span class="p">,</span> <span class="na">nullStr</span><span class="p">:</span> <span class="dl">'</span><span class="s1">~</span><span class="dl">'</span> <span class="p">}</span>
<span class="p">)</span>
<span class="c1">// 'this': ~</span>
<span class="c1">// 'that': 'value'</span>
</code></pre></div>
<p>The <code>doc.toString()</code> method may be called with additional options to control the resulting YAML string representation of the document.</p>

<p>Used by: <code>stringify()</code> and <code>doc.toString()</code></p>

<table><thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>blockQuote</td>
<td><code>boolean ⎮ &#39;folded&#39; ⎮ &#39;literal&#39;</code></td>
<td><code>true</code></td>
<td>Use block quote styles for scalar values where applicable. Set to <code>false</code> to disable block quotes completely.</td>
</tr>
<tr>
<td>collectionStyle</td>
<td><code>&#39;any&#39; ⎮ &#39;block&#39; ⎮ &#39;flow&#39;</code></td>
<td><code>&#39;any&#39;</code></td>
<td>Enforce <code>&#39;block&#39;</code> or <code>&#39;flow&#39;</code> style on maps and sequences. By default, allows each collection to set its own <code>flow: boolean</code> property.</td>
</tr>
<tr>
<td>commentString</td>
<td><code>(comment: string) =&gt; string</code></td>
<td></td>
<td>Output should be valid for the current schema. By default, empty comment lines are left empty, lines consisting of a single space are replaced by <code>#</code>, and all other lines are prefixed with a <code>#</code>.</td>
</tr>
<tr>
<td>defaultKeyType</td>
<td><code>&#39;BLOCK_FOLDED&#39; ⎮ &#39;BLOCK_LITERAL&#39; ⎮</code> <code>&#39;QUOTE_DOUBLE&#39; ⎮ &#39;QUOTE_SINGLE&#39; ⎮</code> <code>&#39;PLAIN&#39; ⎮ null</code></td>
<td><code>null</code></td>
<td>If not <code>null</code>, overrides <code>defaultStringType</code> for implicit key values.</td>
</tr>
<tr>
<td>defaultStringType</td>
<td><code>&#39;BLOCK_FOLDED&#39; ⎮ &#39;BLOCK_LITERAL&#39; ⎮</code> <code>&#39;QUOTE_DOUBLE&#39; ⎮ &#39;QUOTE_SINGLE&#39; ⎮</code> <code>&#39;PLAIN&#39;</code></td>
<td><code>&#39;PLAIN&#39;</code></td>
<td>The default type of string literal used to stringify values.</td>
</tr>
<tr>
<td>directives</td>
<td><code>boolean ⎮ null</code></td>
<td><code>null</code></td>
<td>Include directives in the output. If <code>true</code>, at least the document-start marker <code>---</code> is always included. If <code>false</code>, no directives or marker is ever included. If <code>null</code>, directives and marker may be included if required.</td>
</tr>
<tr>
<td>doubleQuotedAsJSON</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Restrict double-quoted strings to use JSON-compatible syntax.</td>
</tr>
<tr>
<td>doubleQuotedMinMultiLineLength</td>
<td><code>number</code></td>
<td><code>40</code></td>
<td>Minimum length for double-quoted strings to use multiple lines to represent the value.</td>
</tr>
<tr>
<td>falseStr</td>
<td><code>string</code></td>
<td><code>&#39;false&#39;</code></td>
<td>String representation for <code>false</code> values.</td>
</tr>
<tr>
<td>indent</td>
<td><code>number</code></td>
<td><code>2</code></td>
<td>The number of spaces to use when indenting code. Should be a strictly positive integer.</td>
</tr>
<tr>
<td>indentSeq</td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td>Whether block sequences should be indented.</td>
</tr>
<tr>
<td>lineWidth</td>
<td><code>number</code></td>
<td><code>80</code></td>
<td>Maximum line width (set to <code>0</code> to disable folding). This is a soft limit, as only double-quoted semantics allow for inserting a line break in the middle of a word.</td>
</tr>
<tr>
<td>minContentWidth</td>
<td><code>number</code></td>
<td><code>20</code></td>
<td>Minimum line width for highly-indented content (set to <code>0</code> to disable).</td>
</tr>
<tr>
<td>nullStr</td>
<td><code>string</code></td>
<td><code>&#39;null&#39;</code></td>
<td>String representation for <code>null</code> values.</td>
</tr>
<tr>
<td>simpleKeys</td>
<td><code>boolean</code></td>
<td><code>false</code></td>
<td>Require keys to be scalars and always use implicit rather than explicit notation.</td>
</tr>
<tr>
<td>singleQuote</td>
<td><code>boolean ⎮ null</code></td>
<td><code>null</code></td>
<td>Use &#39;single quote&#39; rather than &quot;double quote&quot; where applicable. Set to <code>false</code> to disable single quotes completely.</td>
</tr>
<tr>
<td>trueStr</td>
<td><code>string</code></td>
<td><code>&#39;true&#39;</code></td>
<td>String representation for <code>true</code> values.</td>
</tr>
</tbody></table>
